#!/usr/bin/env python
# @@@ START COPYRIGHT @@@
#
# (C) Copyright 2017-2019 Esgyn Corporation
#
# @@@ END COPYRIGHT @@@

import sys
import subprocess
import json
import os
import re
import grp
import getpass
from optparse import OptionParser

dist_type = os.environ['DIST_TYPE']

def get_options():
    usage = 'usage: %prog [options]\n'
    usage += '  Esgyn cgroup setup script, it set up cgroup configs on a single node.'
    parser = OptionParser(usage=usage)
    parser.add_option("-a", "--add", action="store_true", dest="add", default=False,
                      help="Add a new cgroup.")
    parser.add_option("-m", "--modify", action="store_true", dest="modify", default=False,
                      help="Modify an existing cgroup.")
    parser.add_option("-d", "--delete", action="store_true", dest="delete", default=False,
                      help="Delete an existing cgroup.")
    parser.add_option("--get", action="store_true", dest="get", default=False,
                      help="Get an existing cgroup configuration")
    parser.add_option("--getr", action="store_true", dest="getr", default=False,
                      help="Get an existing cgroup configuration recursively including child cgroups")
    parser.add_option("--si", action="store_true", dest="si", default=False,
                      help="Get system resources on the Esgyn node")
    parser.add_option("-u", "--user", dest="user", metavar="USER",
                      help="Specify the user name to own the cgroup permission.")
    parser.add_option("-g", "--group", dest="group", metavar="GROUP",
                      help="Specify the group name to own the cgroup permission.")
    parser.add_option("--cpu-pct", dest="cpu_pct", metavar="CPU_PERCENT",
                      help="Percentage of CPU to use in cgroup for esgyndb services.")
    parser.add_option("--mem-pct", dest="mem_pct", metavar="MEM_PERCENT",
                      help="Percentage of Memory to use in cgroup for esgyndb services.")
    parser.add_option("--pcgrp", dest="pcgrp", metavar="PARENT_CGROUP",
                      help="Specify parent cgroup name.")
    parser.add_option("--ccgrp", dest="ccgrp", metavar="CHILD_CGROUP",
                      help="Specify child cgroup name.")

    (options, args) = parser.parse_args()
    return options

class Cgroup(object):
    def __init__(self, pname, cname=''):
        self.pname = pname
        self.cname = cname
        if self.pname == 'ESGYNDB':
            esgyn_cg_cpu = os.environ['ESGYN_CG_CPU']
            esgyn_cg_cpuacct = os.environ['ESGYN_CG_CPUACCT']
            esgyn_cg_mem = os.environ['ESGYN_CG_MEM']

            # remove controller name
            self.cpu_pname = esgyn_cg_cpu[esgyn_cg_cpu.find('/'):]
            self.cpuacct_pname = esgyn_cg_cpuacct[esgyn_cg_cpuacct.find('/'):]
            self.mem_pname = esgyn_cg_mem[esgyn_cg_mem.find('/'):]
        else:
            self.cpu_pname = self.cpuacct_pname = self.mem_pname = self.pname

        if self.cname:
            self.cpu_name = '%s/%s' % (self.cpu_pname, self.cname)
            self.cpuacct_name = '%s/%s' % (self.cpuacct_pname, self.cname)
            self.mem_name = '%s/%s' % (self.mem_pname, self.cname)
        else:
            self.cpu_name = self.cpu_pname
            self.cpuacct_name = self.cpuacct_pname
            self.mem_name = self.mem_pname

        self.CPU_SHARES_MAX = 1024

    def _run_cmd(self, cmd):
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, executable='/bin/bash')
        stdout, stderr = p.communicate()
        if p.returncode != 0:
            raise StandardError('Failed to execute cgroup command %s' % cmd)
        return stdout.strip()

    def _check_exist(self, controller, name, report_error=True):
        """ check if cgroup exists or not """
        if self._run_cmd('lscgroup %s:%s' % (controller, name)):
            return True
        else:
            if report_error:
               raise StandardError("Cgroup [%s] doesn't exist in [%s] controller" % (name, controller))
            else:
               return False

    def _set_cpu_shares(self, cpu_shares, name):
        self._check_exist('cpu', name)
        self._run_cmd('cgset -r cpu.shares=%s %s' % (cpu_shares, name))

    def _get_cpu_shares(self, name):
        self._check_exist('cpu', name)
        return int(self._run_cmd("cgget -r cpu.shares %s |grep cpu |awk '{print $2}'" % name))

    def _get_total_cpu_shares(self):
        return int(self._run_cmd("cgget -r cpu.shares / |grep cpu |awk '{print $2}'"))

    def _get_cpu_acct(self, name):
        self._check_exist('cpuacct', name)
        #cpuacct_stat = self._run_cmd("cgget -r cpuacct.stat %s" % name)
        #u, s = re.search(r'user (\d+)\n.*system (\d+)', cpuacct_stat).groups()
        #return (int(u) + int(s))/os.sysconf(os.sysconf_names['SC_CLK_TCK'])
        return int(self._run_cmd("cgget -r cpuacct.usage %s |grep cpu |awk '{print $2}'" % name))
 
    def _get_cgroup_mem(self, mem_controller, name):
        self._check_exist('memory', name)
        return int(self._run_cmd("cgget -r %s %s |grep mem |awk '{print $2}'" % (mem_controller, name)))

    def _get_mem_in_bytes(self, name):
        return self._get_cgroup_mem('memory.limit_in_bytes', name)

    def _get_memsw_in_bytes(self, name):
         return self._get_cgroup_mem('memory.memsw.limit_in_bytes', name)

    def _get_mem_usage_in_bytes(self, name):
        return self._get_cgroup_mem('memory.usage_in_bytes', name)

    def _get_memsw_usage_in_bytes(self, name):
        return self._get_cgroup_mem('memory.memsw.usage_in_bytes', name)

    def _set_mem_in_bytes(self, mem_in_bytes, name):
        self._check_exist('memory', name)
        self._run_cmd('cgset -r memory.limit_in_bytes=%s %s' % (mem_in_bytes, name))

    def _set_memsw_in_bytes(self, memsw_in_bytes, name):
        self._check_exist('memory', name)
        self._run_cmd('cgset -r memory.memsw.limit_in_bytes=%s %s' % (memsw_in_bytes, name))

    def _set_cpu_quota(self, cpu_pct):
        if self.cname:
            parent_cpu_shares = self._get_cpu_shares(self.cpu_pname)
        else:
            parent_cpu_shares = self._get_total_cpu_shares()

        cpu_shares = int(cpu_pct) * parent_cpu_shares / 100
        self._set_cpu_shares(cpu_shares, self.cpu_name)

    def _set_mem_quota(self, mem_pct):
        if self.cname:
            parent_mem_in_bytes = self._get_mem_in_bytes(self.mem_pname)
            if  dist_type != 'Ubuntu':
               parent_memsw_in_bytes = self._get_memsw_in_bytes(self.mem_pname)

        else:
            with open('/proc/meminfo') as f:
                meminfo = f.readlines()
            parent_mem_in_bytes = int([l for l in meminfo if 'MemTotal' in l][0].split()[1])*1024
            parent_memsw_in_bytes = int([l for l in meminfo if 'SwapTotal' in l][0].split()[1])*1024

        mem_in_bytes = int(mem_pct) * parent_mem_in_bytes / 100
        memsw_in_bytes = 3 * mem_in_bytes

        # memory.memsw.limit_in_bytes must always be greater than memory.limit_in_bytes
        # so change this value first if we are increasing the limit by a lot
        # seems to be an issue only on CentOS 7, not CentOS 6
        # see also Linux bug https://bugzilla.redhat.com/show_bug.cgi?id=622462
        curr_memsw_in_bytes = 0
        if dist_type != 'Ubuntu':
           if self._run_cmd('lscgroup memory:%s' % (self.mem_name)):
               curr_memsw_in_bytes = self._get_memsw_in_bytes(self.mem_name)

        if curr_memsw_in_bytes < mem_in_bytes:
            if dist_type != 'Ubuntu':
               self._set_memsw_in_bytes(memsw_in_bytes, self.mem_name)
        self._set_mem_in_bytes(mem_in_bytes, self.mem_name)
        if curr_memsw_in_bytes >= mem_in_bytes:
            if dist_type != 'Ubuntu':
               self._set_memsw_in_bytes(memsw_in_bytes, self.mem_name)

    def _add(self, user, group, controller, name):
        self._run_cmd('cgcreate -g %s:%s -a %s:%s -t %s:%s' % ((controller, name) + (user, group)*2))

    def add(self, user, group):
        self._add(user, group, 'cpu', self.cpu_name)
        self._add(user, group, 'cpuacct', self.cpuacct_name)
        self._add(user, group, 'memory', self.mem_name)

    def _delete(self, controller, name, report_error=True):
        is_exists = self._check_exist(controller, name, report_error)
        if is_exists:
           self._run_cmd('cgdelete -g %s:%s' % (controller, name))

    def delete(self):
        self._delete('cpu', self.cpu_name)
	
	#deleting cpu controller, deletes cpuacct controller on rh7
	#so don't report error if not exists
        self._delete('cpuacct', self.cpuacct_name, False)
	
        self._delete('memory', self.mem_name)

    def modify(self, cpu_pct, mem_pct):
        self._set_cpu_quota(cpu_pct)
        self._set_mem_quota(mem_pct)

    def getSystemInfo(self):
        with open('/proc/meminfo') as f:
            meminfo = f.readlines()
        memKB = int([l for l in meminfo if 'MemTotal' in l][0].split()[1])
        memswKB = int([l for l in meminfo if 'SwapTotal' in l][0].split()[1])
        return {'MemoryKB': memKB, 'SwapKB': memswKB}
 
    def getcgrp(self, cgrp_name=''):
        con = lambda n: n + '/' + cgrp_name
        cpu_name = con(self.cpu_name)
        cpuacct_name = con(self.cpuacct_name)
        mem_name = con(self.mem_name)

        if cgrp_name: # child cgroup
            name = cgrp_name
        else: # parent cgroup
            if self.cname:
                name = self.cname
            else:
                name = self.pname

        if dist_type != 'Ubuntu':
           return {'name': name,
                'cpu.shares': self._get_cpu_shares(cpu_name),
                'total.cpu.shares': self._get_total_cpu_shares(),
                'cpuacct.stat': self._get_cpu_acct(cpuacct_name),
                'memory.limit_in_bytes': self._get_mem_in_bytes(mem_name),
                'memory.usage_in_bytes': self._get_mem_usage_in_bytes(mem_name),
                'memory.memsw.limit_in_bytes': self._get_memsw_in_bytes(mem_name),
                'memory.memsw.usage_in_bytes': self._get_memsw_usage_in_bytes(mem_name)}
        else:
           return {'name': name,
                'cpu.shares': self._get_cpu_shares(cpu_name),
                'total.cpu.shares': self._get_total_cpu_shares(),
                'cpuacct.stat': self._get_cpu_acct(cpuacct_name),
                'memory.limit_in_bytes': self._get_mem_in_bytes(mem_name),
                'memory.usage_in_bytes': self._get_mem_usage_in_bytes(mem_name)}

    def getRecursive(self):
        cgdatarr = []

        # get child cgroups for cpu
        cgrps = self._run_cmd('lscgroup cpu:%s' % self.cpu_name)
        if not cgrps:
            raise StandardError("Cgroup %s doesn't exist" % self.cpu_name)

        for acgrp in cgrps.split(os.linesep):
            # assume there're same child cgroups for all controllers
            cgrp_name = acgrp[acgrp.rfind('/')+1:]

            cgrpdata = self.getcgrp(cgrp_name)
            cgdatarr.append(cgrpdata)
	
        #CPUTIme of parent cgroup includes CPUTime of child groups
        #so compute the tenant level cputime and subtract from top-level ESGYNDB cgroup
        childCPUTime = 0
        for cgdat in cgdatarr:
            if cgdat['name'] != 'ESGYNDB':
                childCPUTime += cgdat['cpuacct.stat']
        
        for cgdat in cgdatarr:
            if cgdat['name'] == 'ESGYNDB':
                cgdat['cpuacct.stat'] = cgdat['cpuacct.stat'] - childCPUTime
                break

        return cgdatarr

def main():
    options = get_options()

    def err(msg):
        sys.stderr.write('[CGROUP_CMD][ERROR] ' + msg + '\n')
        sys.exit(1)

    ### validate parameters ###
    val = 0
    if options.add: val += 1
    if options.delete: val += 1
    if options.modify: val += 1
    if options.get: val += 1
    if options.getr: val += 1
    if options.si: val += 1

    if val != 1:
        err('Must specify only one operation: <add,delete,modify,get,getr,si>')

    login_user = getpass.getuser()
    login_user_group = grp.getgrgid(os.getgid()).gr_name
    user = options.user if options.user else login_user
    group = options.group if options.group else login_user_group
    ccgrp = options.ccgrp if options.ccgrp else ''
    pcgrp = options.pcgrp if options.pcgrp else 'ESGYNDB'

    try:
        cpu_pct = int(options.cpu_pct if options.cpu_pct else 100)
        mem_pct = int(options.mem_pct if options.mem_pct else 100)
    except ValueError:
        err('Percentage should be an integer')

    #if not (1 <= int(cpu_pct) <= 100 and 1 <= int(mem_pct) <= 100):
    #    err('Percentage should be between 1 to 100')

    ### manage cgroup ###
    try:
        cg = Cgroup(pcgrp, ccgrp)
        if options.add:
            cg.add(user, group)
            cg.modify(cpu_pct, mem_pct)
        elif options.delete:
            cg.delete()
        elif options.modify:
            cg.modify(cpu_pct, mem_pct)
        elif options.get:
            print json.dumps(cg.getcgrp())
        elif options.getr:
            print json.dumps(cg.getRecursive())
        elif options.si:
            print json.dumps(cg.getSystemInfo())
    except Exception as e:
        err(str(e))
    else:
        if (not options.get and not options.getr and not options.si):
            print '[CGROUP_CMD] Success!'

if __name__ == '__main__':
    main()
