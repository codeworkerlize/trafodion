/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef parquet_TYPES_H
#define parquet_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>


#include "parquet/util/windows_compatibility.h"

namespace parquet { namespace format {

struct Type {
  enum type {
    BOOLEAN = 0,
    INT32 = 1,
    INT64 = 2,
    INT96 = 3,
    FLOAT = 4,
    DOUBLE = 5,
    BYTE_ARRAY = 6,
    FIXED_LEN_BYTE_ARRAY = 7
  };
};

extern const std::map<int, const char*> _Type_VALUES_TO_NAMES;

struct ConvertedType {
  enum type {
    UTF8 = 0,
    MAP = 1,
    MAP_KEY_VALUE = 2,
    LIST = 3,
    ENUM = 4,
    DECIMAL = 5,
    DATE = 6,
    TIME_MILLIS = 7,
    TIME_MICROS = 8,
    TIMESTAMP_MILLIS = 9,
    TIMESTAMP_MICROS = 10,
    UINT_8 = 11,
    UINT_16 = 12,
    UINT_32 = 13,
    UINT_64 = 14,
    INT_8 = 15,
    INT_16 = 16,
    INT_32 = 17,
    INT_64 = 18,
    JSON = 19,
    BSON = 20,
    INTERVAL = 21
  };
};

extern const std::map<int, const char*> _ConvertedType_VALUES_TO_NAMES;

struct FieldRepetitionType {
  enum type {
    REQUIRED = 0,
    OPTIONAL = 1,
    REPEATED = 2
  };
};

extern const std::map<int, const char*> _FieldRepetitionType_VALUES_TO_NAMES;

struct Encoding {
  enum type {
    PLAIN = 0,
    PLAIN_DICTIONARY = 2,
    RLE = 3,
    BIT_PACKED = 4,
    DELTA_BINARY_PACKED = 5,
    DELTA_LENGTH_BYTE_ARRAY = 6,
    DELTA_BYTE_ARRAY = 7,
    RLE_DICTIONARY = 8
  };
};

extern const std::map<int, const char*> _Encoding_VALUES_TO_NAMES;

struct CompressionCodec {
  enum type {
    UNCOMPRESSED = 0,
    SNAPPY = 1,
    GZIP = 2,
    LZO = 3,
    BROTLI = 4,
    LZ4 = 5,
    ZSTD = 6
  };
};

extern const std::map<int, const char*> _CompressionCodec_VALUES_TO_NAMES;

struct PageType {
  enum type {
    DATA_PAGE = 0,
    INDEX_PAGE = 1,
    DICTIONARY_PAGE = 2,
    DATA_PAGE_V2 = 3
  };
};

extern const std::map<int, const char*> _PageType_VALUES_TO_NAMES;

struct BoundaryOrder {
  enum type {
    UNORDERED = 0,
    ASCENDING = 1,
    DESCENDING = 2
  };
};

extern const std::map<int, const char*> _BoundaryOrder_VALUES_TO_NAMES;

typedef struct _Statistics__isset {
  _Statistics__isset() : max(false), min(false), null_count(false), distinct_count(false), max_value(false), min_value(false) {}
  bool max;
  bool min;
  bool null_count;
  bool distinct_count;
  bool max_value;
  bool min_value;
} _Statistics__isset;

class Statistics {
 public:

  static const char* ascii_fingerprint; // = "2653C00EABDA762BAC3C214A92CD428F";
  static const uint8_t binary_fingerprint[16]; // = {0x26,0x53,0xC0,0x0E,0xAB,0xDA,0x76,0x2B,0xAC,0x3C,0x21,0x4A,0x92,0xCD,0x42,0x8F};

  Statistics() : max(), min(), null_count(0), distinct_count(0), max_value(), min_value() {
  }

  virtual ~Statistics() throw() {}

  std::string max;
  std::string min;
  int64_t null_count;
  int64_t distinct_count;
  std::string max_value;
  std::string min_value;

  _Statistics__isset __isset;

  void __set_max(const std::string& val) {
    max = val;
    __isset.max = true;
  }

  void __set_min(const std::string& val) {
    min = val;
    __isset.min = true;
  }

  void __set_null_count(const int64_t val) {
    null_count = val;
    __isset.null_count = true;
  }

  void __set_distinct_count(const int64_t val) {
    distinct_count = val;
    __isset.distinct_count = true;
  }

  void __set_max_value(const std::string& val) {
    max_value = val;
    __isset.max_value = true;
  }

  void __set_min_value(const std::string& val) {
    min_value = val;
    __isset.min_value = true;
  }

  bool operator == (const Statistics & rhs) const
  {
    if (__isset.max != rhs.__isset.max)
      return false;
    else if (__isset.max && !(max == rhs.max))
      return false;
    if (__isset.min != rhs.__isset.min)
      return false;
    else if (__isset.min && !(min == rhs.min))
      return false;
    if (__isset.null_count != rhs.__isset.null_count)
      return false;
    else if (__isset.null_count && !(null_count == rhs.null_count))
      return false;
    if (__isset.distinct_count != rhs.__isset.distinct_count)
      return false;
    else if (__isset.distinct_count && !(distinct_count == rhs.distinct_count))
      return false;
    if (__isset.max_value != rhs.__isset.max_value)
      return false;
    else if (__isset.max_value && !(max_value == rhs.max_value))
      return false;
    if (__isset.min_value != rhs.__isset.min_value)
      return false;
    else if (__isset.min_value && !(min_value == rhs.min_value))
      return false;
    return true;
  }
  bool operator != (const Statistics &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Statistics & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Statistics &a, Statistics &b);


class StringType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  StringType() {
  }

  virtual ~StringType() throw() {}


  bool operator == (const StringType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const StringType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const StringType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(StringType &a, StringType &b);


class UUIDType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  UUIDType() {
  }

  virtual ~UUIDType() throw() {}


  bool operator == (const UUIDType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const UUIDType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UUIDType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(UUIDType &a, UUIDType &b);


class MapType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  MapType() {
  }

  virtual ~MapType() throw() {}


  bool operator == (const MapType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MapType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MapType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MapType &a, MapType &b);


class ListType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  ListType() {
  }

  virtual ~ListType() throw() {}


  bool operator == (const ListType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ListType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ListType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ListType &a, ListType &b);


class EnumType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  EnumType() {
  }

  virtual ~EnumType() throw() {}


  bool operator == (const EnumType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const EnumType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EnumType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EnumType &a, EnumType &b);


class DateType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  DateType() {
  }

  virtual ~DateType() throw() {}


  bool operator == (const DateType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const DateType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DateType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DateType &a, DateType &b);


class NullType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  NullType() {
  }

  virtual ~NullType() throw() {}


  bool operator == (const NullType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const NullType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NullType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(NullType &a, NullType &b);


class DecimalType {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  DecimalType() : scale(0), precision(0) {
  }

  virtual ~DecimalType() throw() {}

  int32_t scale;
  int32_t precision;

  void __set_scale(const int32_t val) {
    scale = val;
  }

  void __set_precision(const int32_t val) {
    precision = val;
  }

  bool operator == (const DecimalType & rhs) const
  {
    if (!(scale == rhs.scale))
      return false;
    if (!(precision == rhs.precision))
      return false;
    return true;
  }
  bool operator != (const DecimalType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DecimalType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DecimalType &a, DecimalType &b);


class MilliSeconds {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  MilliSeconds() {
  }

  virtual ~MilliSeconds() throw() {}


  bool operator == (const MilliSeconds & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MilliSeconds &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MilliSeconds & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MilliSeconds &a, MilliSeconds &b);


class MicroSeconds {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  MicroSeconds() {
  }

  virtual ~MicroSeconds() throw() {}


  bool operator == (const MicroSeconds & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MicroSeconds &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MicroSeconds & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MicroSeconds &a, MicroSeconds &b);

typedef struct _TimeUnit__isset {
  _TimeUnit__isset() : MILLIS(false), MICROS(false) {}
  bool MILLIS;
  bool MICROS;
} _TimeUnit__isset;

class TimeUnit {
 public:

  static const char* ascii_fingerprint; // = "931F05C6CC509EB7432FC696B67852F5";
  static const uint8_t binary_fingerprint[16]; // = {0x93,0x1F,0x05,0xC6,0xCC,0x50,0x9E,0xB7,0x43,0x2F,0xC6,0x96,0xB6,0x78,0x52,0xF5};

  TimeUnit() {
  }

  virtual ~TimeUnit() throw() {}

  MilliSeconds MILLIS;
  MicroSeconds MICROS;

  _TimeUnit__isset __isset;

  void __set_MILLIS(const MilliSeconds& val) {
    MILLIS = val;
  }

  void __set_MICROS(const MicroSeconds& val) {
    MICROS = val;
  }

  bool operator == (const TimeUnit & rhs) const
  {
    if (!(MILLIS == rhs.MILLIS))
      return false;
    if (!(MICROS == rhs.MICROS))
      return false;
    return true;
  }
  bool operator != (const TimeUnit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimeUnit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TimeUnit &a, TimeUnit &b);


class TimestampType {
 public:

  static const char* ascii_fingerprint; // = "68D856A5AB64EF8CFD10B97CED4325A5";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0xD8,0x56,0xA5,0xAB,0x64,0xEF,0x8C,0xFD,0x10,0xB9,0x7C,0xED,0x43,0x25,0xA5};

  TimestampType() : isAdjustedToUTC(0) {
  }

  virtual ~TimestampType() throw() {}

  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val) {
    isAdjustedToUTC = val;
  }

  void __set_unit(const TimeUnit& val) {
    unit = val;
  }

  bool operator == (const TimestampType & rhs) const
  {
    if (!(isAdjustedToUTC == rhs.isAdjustedToUTC))
      return false;
    if (!(unit == rhs.unit))
      return false;
    return true;
  }
  bool operator != (const TimestampType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimestampType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TimestampType &a, TimestampType &b);


class TimeType {
 public:

  static const char* ascii_fingerprint; // = "68D856A5AB64EF8CFD10B97CED4325A5";
  static const uint8_t binary_fingerprint[16]; // = {0x68,0xD8,0x56,0xA5,0xAB,0x64,0xEF,0x8C,0xFD,0x10,0xB9,0x7C,0xED,0x43,0x25,0xA5};

  TimeType() : isAdjustedToUTC(0) {
  }

  virtual ~TimeType() throw() {}

  bool isAdjustedToUTC;
  TimeUnit unit;

  void __set_isAdjustedToUTC(const bool val) {
    isAdjustedToUTC = val;
  }

  void __set_unit(const TimeUnit& val) {
    unit = val;
  }

  bool operator == (const TimeType & rhs) const
  {
    if (!(isAdjustedToUTC == rhs.isAdjustedToUTC))
      return false;
    if (!(unit == rhs.unit))
      return false;
    return true;
  }
  bool operator != (const TimeType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TimeType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TimeType &a, TimeType &b);


class IntType {
 public:

  static const char* ascii_fingerprint; // = "1F3F275AAC68AEEBF4BFF3C690FE56E9";
  static const uint8_t binary_fingerprint[16]; // = {0x1F,0x3F,0x27,0x5A,0xAC,0x68,0xAE,0xEB,0xF4,0xBF,0xF3,0xC6,0x90,0xFE,0x56,0xE9};

  IntType() : bitWidth(0), isSigned(0) {
  }

  virtual ~IntType() throw() {}

  int8_t bitWidth;
  bool isSigned;

  void __set_bitWidth(const int8_t val) {
    bitWidth = val;
  }

  void __set_isSigned(const bool val) {
    isSigned = val;
  }

  bool operator == (const IntType & rhs) const
  {
    if (!(bitWidth == rhs.bitWidth))
      return false;
    if (!(isSigned == rhs.isSigned))
      return false;
    return true;
  }
  bool operator != (const IntType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IntType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IntType &a, IntType &b);


class JsonType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  JsonType() {
  }

  virtual ~JsonType() throw() {}


  bool operator == (const JsonType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const JsonType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const JsonType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(JsonType &a, JsonType &b);


class BsonType {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  BsonType() {
  }

  virtual ~BsonType() throw() {}


  bool operator == (const BsonType & /* rhs */) const
  {
    return true;
  }
  bool operator != (const BsonType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BsonType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(BsonType &a, BsonType &b);

typedef struct _LogicalType__isset {
  _LogicalType__isset() : STRING(false), MAP(false), LIST(false), ENUM(false), DECIMAL(false), DATE(false), TIME(false), TIMESTAMP(false), INTEGER(false), UNKNOWN(false), JSON(false), BSON(false) {}
  bool STRING;
  bool MAP;
  bool LIST;
  bool ENUM;
  bool DECIMAL;
  bool DATE;
  bool TIME;
  bool TIMESTAMP;
  bool INTEGER;
  bool UNKNOWN;
  bool JSON;
  bool BSON;
} _LogicalType__isset;

class LogicalType {
 public:

  static const char* ascii_fingerprint; // = "84DA8F8E928A564F070FF8F3702264DD";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0xDA,0x8F,0x8E,0x92,0x8A,0x56,0x4F,0x07,0x0F,0xF8,0xF3,0x70,0x22,0x64,0xDD};

  LogicalType() {
  }

  virtual ~LogicalType() throw() {}

  StringType STRING;
  MapType MAP;
  ListType LIST;
  EnumType ENUM;
  DecimalType DECIMAL;
  DateType DATE;
  TimeType TIME;
  TimestampType TIMESTAMP;
  IntType INTEGER;
  NullType UNKNOWN;
  JsonType JSON;
  BsonType BSON;

  _LogicalType__isset __isset;

  void __set_STRING(const StringType& val) {
    STRING = val;
  }

  void __set_MAP(const MapType& val) {
    MAP = val;
  }

  void __set_LIST(const ListType& val) {
    LIST = val;
  }

  void __set_ENUM(const EnumType& val) {
    ENUM = val;
  }

  void __set_DECIMAL(const DecimalType& val) {
    DECIMAL = val;
  }

  void __set_DATE(const DateType& val) {
    DATE = val;
  }

  void __set_TIME(const TimeType& val) {
    TIME = val;
  }

  void __set_TIMESTAMP(const TimestampType& val) {
    TIMESTAMP = val;
  }

  void __set_INTEGER(const IntType& val) {
    INTEGER = val;
  }

  void __set_UNKNOWN(const NullType& val) {
    UNKNOWN = val;
  }

  void __set_JSON(const JsonType& val) {
    JSON = val;
  }

  void __set_BSON(const BsonType& val) {
    BSON = val;
  }

  bool operator == (const LogicalType & rhs) const
  {
    if (!(STRING == rhs.STRING))
      return false;
    if (!(MAP == rhs.MAP))
      return false;
    if (!(LIST == rhs.LIST))
      return false;
    if (!(ENUM == rhs.ENUM))
      return false;
    if (!(DECIMAL == rhs.DECIMAL))
      return false;
    if (!(DATE == rhs.DATE))
      return false;
    if (!(TIME == rhs.TIME))
      return false;
    if (!(TIMESTAMP == rhs.TIMESTAMP))
      return false;
    if (!(INTEGER == rhs.INTEGER))
      return false;
    if (!(UNKNOWN == rhs.UNKNOWN))
      return false;
    if (!(JSON == rhs.JSON))
      return false;
    if (!(BSON == rhs.BSON))
      return false;
    return true;
  }
  bool operator != (const LogicalType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LogicalType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LogicalType &a, LogicalType &b);

typedef struct _SchemaElement__isset {
  _SchemaElement__isset() : type(false), type_length(false), repetition_type(false), num_children(false), converted_type(false), scale(false), precision(false), field_id(false), logicalType(false) {}
  bool type;
  bool type_length;
  bool repetition_type;
  bool num_children;
  bool converted_type;
  bool scale;
  bool precision;
  bool field_id;
  bool logicalType;
} _SchemaElement__isset;

class SchemaElement {
 public:

  static const char* ascii_fingerprint; // = "98D7BCD9FAFD4EC8CEF80F535BFFCF23";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0xD7,0xBC,0xD9,0xFA,0xFD,0x4E,0xC8,0xCE,0xF8,0x0F,0x53,0x5B,0xFF,0xCF,0x23};

  SchemaElement() : type((Type::type)0), type_length(0), repetition_type((FieldRepetitionType::type)0), name(), num_children(0), converted_type((ConvertedType::type)0), scale(0), precision(0), field_id(0) {
  }

  virtual ~SchemaElement() throw() {}

  Type::type type;
  int32_t type_length;
  FieldRepetitionType::type repetition_type;
  std::string name;
  int32_t num_children;
  ConvertedType::type converted_type;
  int32_t scale;
  int32_t precision;
  int32_t field_id;
  LogicalType logicalType;

  _SchemaElement__isset __isset;

  void __set_type(const Type::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_type_length(const int32_t val) {
    type_length = val;
    __isset.type_length = true;
  }

  void __set_repetition_type(const FieldRepetitionType::type val) {
    repetition_type = val;
    __isset.repetition_type = true;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
    __isset.num_children = true;
  }

  void __set_converted_type(const ConvertedType::type val) {
    converted_type = val;
    __isset.converted_type = true;
  }

  void __set_scale(const int32_t val) {
    scale = val;
    __isset.scale = true;
  }

  void __set_precision(const int32_t val) {
    precision = val;
    __isset.precision = true;
  }

  void __set_field_id(const int32_t val) {
    field_id = val;
    __isset.field_id = true;
  }

  void __set_logicalType(const LogicalType& val) {
    logicalType = val;
    __isset.logicalType = true;
  }

  bool operator == (const SchemaElement & rhs) const
  {
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.type_length != rhs.__isset.type_length)
      return false;
    else if (__isset.type_length && !(type_length == rhs.type_length))
      return false;
    if (__isset.repetition_type != rhs.__isset.repetition_type)
      return false;
    else if (__isset.repetition_type && !(repetition_type == rhs.repetition_type))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.num_children != rhs.__isset.num_children)
      return false;
    else if (__isset.num_children && !(num_children == rhs.num_children))
      return false;
    if (__isset.converted_type != rhs.__isset.converted_type)
      return false;
    else if (__isset.converted_type && !(converted_type == rhs.converted_type))
      return false;
    if (__isset.scale != rhs.__isset.scale)
      return false;
    else if (__isset.scale && !(scale == rhs.scale))
      return false;
    if (__isset.precision != rhs.__isset.precision)
      return false;
    else if (__isset.precision && !(precision == rhs.precision))
      return false;
    if (__isset.field_id != rhs.__isset.field_id)
      return false;
    else if (__isset.field_id && !(field_id == rhs.field_id))
      return false;
    if (__isset.logicalType != rhs.__isset.logicalType)
      return false;
    else if (__isset.logicalType && !(logicalType == rhs.logicalType))
      return false;
    return true;
  }
  bool operator != (const SchemaElement &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaElement & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SchemaElement &a, SchemaElement &b);

typedef struct _DataPageHeader__isset {
  _DataPageHeader__isset() : statistics(false) {}
  bool statistics;
} _DataPageHeader__isset;

class DataPageHeader {
 public:

  static const char* ascii_fingerprint; // = "370A3886D183A11DA1B5F52C2E1B47F2";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x0A,0x38,0x86,0xD1,0x83,0xA1,0x1D,0xA1,0xB5,0xF5,0x2C,0x2E,0x1B,0x47,0xF2};

  DataPageHeader() : num_values(0), encoding((Encoding::type)0), definition_level_encoding((Encoding::type)0), repetition_level_encoding((Encoding::type)0) {
  }

  virtual ~DataPageHeader() throw() {}

  int32_t num_values;
  Encoding::type encoding;
  Encoding::type definition_level_encoding;
  Encoding::type repetition_level_encoding;
  Statistics statistics;

  _DataPageHeader__isset __isset;

  void __set_num_values(const int32_t val) {
    num_values = val;
  }

  void __set_encoding(const Encoding::type val) {
    encoding = val;
  }

  void __set_definition_level_encoding(const Encoding::type val) {
    definition_level_encoding = val;
  }

  void __set_repetition_level_encoding(const Encoding::type val) {
    repetition_level_encoding = val;
  }

  void __set_statistics(const Statistics& val) {
    statistics = val;
    __isset.statistics = true;
  }

  bool operator == (const DataPageHeader & rhs) const
  {
    if (!(num_values == rhs.num_values))
      return false;
    if (!(encoding == rhs.encoding))
      return false;
    if (!(definition_level_encoding == rhs.definition_level_encoding))
      return false;
    if (!(repetition_level_encoding == rhs.repetition_level_encoding))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    return true;
  }
  bool operator != (const DataPageHeader &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageHeader & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DataPageHeader &a, DataPageHeader &b);


class IndexPageHeader {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  IndexPageHeader() {
  }

  virtual ~IndexPageHeader() throw() {}


  bool operator == (const IndexPageHeader & /* rhs */) const
  {
    return true;
  }
  bool operator != (const IndexPageHeader &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IndexPageHeader & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(IndexPageHeader &a, IndexPageHeader &b);

typedef struct _DictionaryPageHeader__isset {
  _DictionaryPageHeader__isset() : is_sorted(false) {}
  bool is_sorted;
} _DictionaryPageHeader__isset;

class DictionaryPageHeader {
 public:

  static const char* ascii_fingerprint; // = "B149E4528254D495610C22AE4BD539C5";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x49,0xE4,0x52,0x82,0x54,0xD4,0x95,0x61,0x0C,0x22,0xAE,0x4B,0xD5,0x39,0xC5};

  DictionaryPageHeader() : num_values(0), encoding((Encoding::type)0), is_sorted(0) {
  }

  virtual ~DictionaryPageHeader() throw() {}

  int32_t num_values;
  Encoding::type encoding;
  bool is_sorted;

  _DictionaryPageHeader__isset __isset;

  void __set_num_values(const int32_t val) {
    num_values = val;
  }

  void __set_encoding(const Encoding::type val) {
    encoding = val;
  }

  void __set_is_sorted(const bool val) {
    is_sorted = val;
    __isset.is_sorted = true;
  }

  bool operator == (const DictionaryPageHeader & rhs) const
  {
    if (!(num_values == rhs.num_values))
      return false;
    if (!(encoding == rhs.encoding))
      return false;
    if (__isset.is_sorted != rhs.__isset.is_sorted)
      return false;
    else if (__isset.is_sorted && !(is_sorted == rhs.is_sorted))
      return false;
    return true;
  }
  bool operator != (const DictionaryPageHeader &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DictionaryPageHeader & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DictionaryPageHeader &a, DictionaryPageHeader &b);

typedef struct _DataPageHeaderV2__isset {
  _DataPageHeaderV2__isset() : is_compressed(true), statistics(false) {}
  bool is_compressed;
  bool statistics;
} _DataPageHeaderV2__isset;

class DataPageHeaderV2 {
 public:

  static const char* ascii_fingerprint; // = "5521807846C08CA2BA5A97E467B7F4FB";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0x21,0x80,0x78,0x46,0xC0,0x8C,0xA2,0xBA,0x5A,0x97,0xE4,0x67,0xB7,0xF4,0xFB};

  DataPageHeaderV2() : num_values(0), num_nulls(0), num_rows(0), encoding((Encoding::type)0), definition_levels_byte_length(0), repetition_levels_byte_length(0), is_compressed(true) {
  }

  virtual ~DataPageHeaderV2() throw() {}

  int32_t num_values;
  int32_t num_nulls;
  int32_t num_rows;
  Encoding::type encoding;
  int32_t definition_levels_byte_length;
  int32_t repetition_levels_byte_length;
  bool is_compressed;
  Statistics statistics;

  _DataPageHeaderV2__isset __isset;

  void __set_num_values(const int32_t val) {
    num_values = val;
  }

  void __set_num_nulls(const int32_t val) {
    num_nulls = val;
  }

  void __set_num_rows(const int32_t val) {
    num_rows = val;
  }

  void __set_encoding(const Encoding::type val) {
    encoding = val;
  }

  void __set_definition_levels_byte_length(const int32_t val) {
    definition_levels_byte_length = val;
  }

  void __set_repetition_levels_byte_length(const int32_t val) {
    repetition_levels_byte_length = val;
  }

  void __set_is_compressed(const bool val) {
    is_compressed = val;
    __isset.is_compressed = true;
  }

  void __set_statistics(const Statistics& val) {
    statistics = val;
    __isset.statistics = true;
  }

  bool operator == (const DataPageHeaderV2 & rhs) const
  {
    if (!(num_values == rhs.num_values))
      return false;
    if (!(num_nulls == rhs.num_nulls))
      return false;
    if (!(num_rows == rhs.num_rows))
      return false;
    if (!(encoding == rhs.encoding))
      return false;
    if (!(definition_levels_byte_length == rhs.definition_levels_byte_length))
      return false;
    if (!(repetition_levels_byte_length == rhs.repetition_levels_byte_length))
      return false;
    if (__isset.is_compressed != rhs.__isset.is_compressed)
      return false;
    else if (__isset.is_compressed && !(is_compressed == rhs.is_compressed))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    return true;
  }
  bool operator != (const DataPageHeaderV2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DataPageHeaderV2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DataPageHeaderV2 &a, DataPageHeaderV2 &b);

typedef struct _PageHeader__isset {
  _PageHeader__isset() : crc(false), data_page_header(false), index_page_header(false), dictionary_page_header(false), data_page_header_v2(false) {}
  bool crc;
  bool data_page_header;
  bool index_page_header;
  bool dictionary_page_header;
  bool data_page_header_v2;
} _PageHeader__isset;

class PageHeader {
 public:

  static const char* ascii_fingerprint; // = "FE48BD194176A3633294CCB098E35CE8";
  static const uint8_t binary_fingerprint[16]; // = {0xFE,0x48,0xBD,0x19,0x41,0x76,0xA3,0x63,0x32,0x94,0xCC,0xB0,0x98,0xE3,0x5C,0xE8};

  PageHeader() : type((PageType::type)0), uncompressed_page_size(0), compressed_page_size(0), crc(0) {
  }

  virtual ~PageHeader() throw() {}

  PageType::type type;
  int32_t uncompressed_page_size;
  int32_t compressed_page_size;
  int32_t crc;
  DataPageHeader data_page_header;
  IndexPageHeader index_page_header;
  DictionaryPageHeader dictionary_page_header;
  DataPageHeaderV2 data_page_header_v2;

  _PageHeader__isset __isset;

  void __set_type(const PageType::type val) {
    type = val;
  }

  void __set_uncompressed_page_size(const int32_t val) {
    uncompressed_page_size = val;
  }

  void __set_compressed_page_size(const int32_t val) {
    compressed_page_size = val;
  }

  void __set_crc(const int32_t val) {
    crc = val;
    __isset.crc = true;
  }

  void __set_data_page_header(const DataPageHeader& val) {
    data_page_header = val;
    __isset.data_page_header = true;
  }

  void __set_index_page_header(const IndexPageHeader& val) {
    index_page_header = val;
    __isset.index_page_header = true;
  }

  void __set_dictionary_page_header(const DictionaryPageHeader& val) {
    dictionary_page_header = val;
    __isset.dictionary_page_header = true;
  }

  void __set_data_page_header_v2(const DataPageHeaderV2& val) {
    data_page_header_v2 = val;
    __isset.data_page_header_v2 = true;
  }

  bool operator == (const PageHeader & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(uncompressed_page_size == rhs.uncompressed_page_size))
      return false;
    if (!(compressed_page_size == rhs.compressed_page_size))
      return false;
    if (__isset.crc != rhs.__isset.crc)
      return false;
    else if (__isset.crc && !(crc == rhs.crc))
      return false;
    if (__isset.data_page_header != rhs.__isset.data_page_header)
      return false;
    else if (__isset.data_page_header && !(data_page_header == rhs.data_page_header))
      return false;
    if (__isset.index_page_header != rhs.__isset.index_page_header)
      return false;
    else if (__isset.index_page_header && !(index_page_header == rhs.index_page_header))
      return false;
    if (__isset.dictionary_page_header != rhs.__isset.dictionary_page_header)
      return false;
    else if (__isset.dictionary_page_header && !(dictionary_page_header == rhs.dictionary_page_header))
      return false;
    if (__isset.data_page_header_v2 != rhs.__isset.data_page_header_v2)
      return false;
    else if (__isset.data_page_header_v2 && !(data_page_header_v2 == rhs.data_page_header_v2))
      return false;
    return true;
  }
  bool operator != (const PageHeader &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PageHeader & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PageHeader &a, PageHeader &b);

typedef struct _KeyValue__isset {
  _KeyValue__isset() : value(false) {}
  bool value;
} _KeyValue__isset;

class KeyValue {
 public:

  static const char* ascii_fingerprint; // = "5B708A954C550ECA9C1A49D3C5CAFAB9";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

  KeyValue() : key(), value() {
  }

  virtual ~KeyValue() throw() {}

  std::string key;
  std::string value;

  _KeyValue__isset __isset;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const KeyValue & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const KeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(KeyValue &a, KeyValue &b);


class SortingColumn {
 public:

  static const char* ascii_fingerprint; // = "F079C2D58A783AD90F9BE05D10DBBC6F";
  static const uint8_t binary_fingerprint[16]; // = {0xF0,0x79,0xC2,0xD5,0x8A,0x78,0x3A,0xD9,0x0F,0x9B,0xE0,0x5D,0x10,0xDB,0xBC,0x6F};

  SortingColumn() : column_idx(0), descending(0), nulls_first(0) {
  }

  virtual ~SortingColumn() throw() {}

  int32_t column_idx;
  bool descending;
  bool nulls_first;

  void __set_column_idx(const int32_t val) {
    column_idx = val;
  }

  void __set_descending(const bool val) {
    descending = val;
  }

  void __set_nulls_first(const bool val) {
    nulls_first = val;
  }

  bool operator == (const SortingColumn & rhs) const
  {
    if (!(column_idx == rhs.column_idx))
      return false;
    if (!(descending == rhs.descending))
      return false;
    if (!(nulls_first == rhs.nulls_first))
      return false;
    return true;
  }
  bool operator != (const SortingColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SortingColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SortingColumn &a, SortingColumn &b);


class PageEncodingStats {
 public:

  static const char* ascii_fingerprint; // = "5F1BEE04836FAA3055D3EE2492AE44FB";
  static const uint8_t binary_fingerprint[16]; // = {0x5F,0x1B,0xEE,0x04,0x83,0x6F,0xAA,0x30,0x55,0xD3,0xEE,0x24,0x92,0xAE,0x44,0xFB};

  PageEncodingStats() : page_type((PageType::type)0), encoding((Encoding::type)0), count(0) {
  }

  virtual ~PageEncodingStats() throw() {}

  PageType::type page_type;
  Encoding::type encoding;
  int32_t count;

  void __set_page_type(const PageType::type val) {
    page_type = val;
  }

  void __set_encoding(const Encoding::type val) {
    encoding = val;
  }

  void __set_count(const int32_t val) {
    count = val;
  }

  bool operator == (const PageEncodingStats & rhs) const
  {
    if (!(page_type == rhs.page_type))
      return false;
    if (!(encoding == rhs.encoding))
      return false;
    if (!(count == rhs.count))
      return false;
    return true;
  }
  bool operator != (const PageEncodingStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PageEncodingStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PageEncodingStats &a, PageEncodingStats &b);

typedef struct _ColumnMetaData__isset {
  _ColumnMetaData__isset() : key_value_metadata(false), index_page_offset(false), dictionary_page_offset(false), statistics(false), encoding_stats(false) {}
  bool key_value_metadata;
  bool index_page_offset;
  bool dictionary_page_offset;
  bool statistics;
  bool encoding_stats;
} _ColumnMetaData__isset;

class ColumnMetaData {
 public:

  static const char* ascii_fingerprint; // = "F554E94483D3FF4888F7DC6DDEFC1897";
  static const uint8_t binary_fingerprint[16]; // = {0xF5,0x54,0xE9,0x44,0x83,0xD3,0xFF,0x48,0x88,0xF7,0xDC,0x6D,0xDE,0xFC,0x18,0x97};

  ColumnMetaData() : type((Type::type)0), codec((CompressionCodec::type)0), num_values(0), total_uncompressed_size(0), total_compressed_size(0), data_page_offset(0), index_page_offset(0), dictionary_page_offset(0) {
  }

  virtual ~ColumnMetaData() throw() {}

  Type::type type;
  std::vector<Encoding::type>  encodings;
  std::vector<std::string>  path_in_schema;
  CompressionCodec::type codec;
  int64_t num_values;
  int64_t total_uncompressed_size;
  int64_t total_compressed_size;
  std::vector<KeyValue>  key_value_metadata;
  int64_t data_page_offset;
  int64_t index_page_offset;
  int64_t dictionary_page_offset;
  Statistics statistics;
  std::vector<PageEncodingStats>  encoding_stats;

  _ColumnMetaData__isset __isset;

  void __set_type(const Type::type val) {
    type = val;
  }

  void __set_encodings(const std::vector<Encoding::type> & val) {
    encodings = val;
  }

  void __set_path_in_schema(const std::vector<std::string> & val) {
    path_in_schema = val;
  }

  void __set_codec(const CompressionCodec::type val) {
    codec = val;
  }

  void __set_num_values(const int64_t val) {
    num_values = val;
  }

  void __set_total_uncompressed_size(const int64_t val) {
    total_uncompressed_size = val;
  }

  void __set_total_compressed_size(const int64_t val) {
    total_compressed_size = val;
  }

  void __set_key_value_metadata(const std::vector<KeyValue> & val) {
    key_value_metadata = val;
    __isset.key_value_metadata = true;
  }

  void __set_data_page_offset(const int64_t val) {
    data_page_offset = val;
  }

  void __set_index_page_offset(const int64_t val) {
    index_page_offset = val;
    __isset.index_page_offset = true;
  }

  void __set_dictionary_page_offset(const int64_t val) {
    dictionary_page_offset = val;
    __isset.dictionary_page_offset = true;
  }

  void __set_statistics(const Statistics& val) {
    statistics = val;
    __isset.statistics = true;
  }

  void __set_encoding_stats(const std::vector<PageEncodingStats> & val) {
    encoding_stats = val;
    __isset.encoding_stats = true;
  }

  bool operator == (const ColumnMetaData & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(encodings == rhs.encodings))
      return false;
    if (!(path_in_schema == rhs.path_in_schema))
      return false;
    if (!(codec == rhs.codec))
      return false;
    if (!(num_values == rhs.num_values))
      return false;
    if (!(total_uncompressed_size == rhs.total_uncompressed_size))
      return false;
    if (!(total_compressed_size == rhs.total_compressed_size))
      return false;
    if (__isset.key_value_metadata != rhs.__isset.key_value_metadata)
      return false;
    else if (__isset.key_value_metadata && !(key_value_metadata == rhs.key_value_metadata))
      return false;
    if (!(data_page_offset == rhs.data_page_offset))
      return false;
    if (__isset.index_page_offset != rhs.__isset.index_page_offset)
      return false;
    else if (__isset.index_page_offset && !(index_page_offset == rhs.index_page_offset))
      return false;
    if (__isset.dictionary_page_offset != rhs.__isset.dictionary_page_offset)
      return false;
    else if (__isset.dictionary_page_offset && !(dictionary_page_offset == rhs.dictionary_page_offset))
      return false;
    if (__isset.statistics != rhs.__isset.statistics)
      return false;
    else if (__isset.statistics && !(statistics == rhs.statistics))
      return false;
    if (__isset.encoding_stats != rhs.__isset.encoding_stats)
      return false;
    else if (__isset.encoding_stats && !(encoding_stats == rhs.encoding_stats))
      return false;
    return true;
  }
  bool operator != (const ColumnMetaData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnMetaData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnMetaData &a, ColumnMetaData &b);

typedef struct _ColumnChunk__isset {
  _ColumnChunk__isset() : file_path(false), meta_data(false), offset_index_offset(false), offset_index_length(false), column_index_offset(false), column_index_length(false) {}
  bool file_path;
  bool meta_data;
  bool offset_index_offset;
  bool offset_index_length;
  bool column_index_offset;
  bool column_index_length;
} _ColumnChunk__isset;

class ColumnChunk {
 public:

  static const char* ascii_fingerprint; // = "CE673D386B013BA5D81A822C7ED23F61";
  static const uint8_t binary_fingerprint[16]; // = {0xCE,0x67,0x3D,0x38,0x6B,0x01,0x3B,0xA5,0xD8,0x1A,0x82,0x2C,0x7E,0xD2,0x3F,0x61};

  ColumnChunk() : file_path(), file_offset(0), offset_index_offset(0), offset_index_length(0), column_index_offset(0), column_index_length(0) {
  }

  virtual ~ColumnChunk() throw() {}

  std::string file_path;
  int64_t file_offset;
  ColumnMetaData meta_data;
  int64_t offset_index_offset;
  int32_t offset_index_length;
  int64_t column_index_offset;
  int32_t column_index_length;

  _ColumnChunk__isset __isset;

  void __set_file_path(const std::string& val) {
    file_path = val;
    __isset.file_path = true;
  }

  void __set_file_offset(const int64_t val) {
    file_offset = val;
  }

  void __set_meta_data(const ColumnMetaData& val) {
    meta_data = val;
    __isset.meta_data = true;
  }

  void __set_offset_index_offset(const int64_t val) {
    offset_index_offset = val;
    __isset.offset_index_offset = true;
  }

  void __set_offset_index_length(const int32_t val) {
    offset_index_length = val;
    __isset.offset_index_length = true;
  }

  void __set_column_index_offset(const int64_t val) {
    column_index_offset = val;
    __isset.column_index_offset = true;
  }

  void __set_column_index_length(const int32_t val) {
    column_index_length = val;
    __isset.column_index_length = true;
  }

  bool operator == (const ColumnChunk & rhs) const
  {
    if (__isset.file_path != rhs.__isset.file_path)
      return false;
    else if (__isset.file_path && !(file_path == rhs.file_path))
      return false;
    if (!(file_offset == rhs.file_offset))
      return false;
    if (__isset.meta_data != rhs.__isset.meta_data)
      return false;
    else if (__isset.meta_data && !(meta_data == rhs.meta_data))
      return false;
    if (__isset.offset_index_offset != rhs.__isset.offset_index_offset)
      return false;
    else if (__isset.offset_index_offset && !(offset_index_offset == rhs.offset_index_offset))
      return false;
    if (__isset.offset_index_length != rhs.__isset.offset_index_length)
      return false;
    else if (__isset.offset_index_length && !(offset_index_length == rhs.offset_index_length))
      return false;
    if (__isset.column_index_offset != rhs.__isset.column_index_offset)
      return false;
    else if (__isset.column_index_offset && !(column_index_offset == rhs.column_index_offset))
      return false;
    if (__isset.column_index_length != rhs.__isset.column_index_length)
      return false;
    else if (__isset.column_index_length && !(column_index_length == rhs.column_index_length))
      return false;
    return true;
  }
  bool operator != (const ColumnChunk &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnChunk & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnChunk &a, ColumnChunk &b);

typedef struct _RowGroup__isset {
  _RowGroup__isset() : sorting_columns(false) {}
  bool sorting_columns;
} _RowGroup__isset;

class RowGroup {
 public:

  static const char* ascii_fingerprint; // = "62813368B091063DF3DEAA66170A7E07";
  static const uint8_t binary_fingerprint[16]; // = {0x62,0x81,0x33,0x68,0xB0,0x91,0x06,0x3D,0xF3,0xDE,0xAA,0x66,0x17,0x0A,0x7E,0x07};

  RowGroup() : total_byte_size(0), num_rows(0) {
  }

  virtual ~RowGroup() throw() {}

  std::vector<ColumnChunk>  columns;
  int64_t total_byte_size;
  int64_t num_rows;
  std::vector<SortingColumn>  sorting_columns;

  _RowGroup__isset __isset;

  void __set_columns(const std::vector<ColumnChunk> & val) {
    columns = val;
  }

  void __set_total_byte_size(const int64_t val) {
    total_byte_size = val;
  }

  void __set_num_rows(const int64_t val) {
    num_rows = val;
  }

  void __set_sorting_columns(const std::vector<SortingColumn> & val) {
    sorting_columns = val;
    __isset.sorting_columns = true;
  }

  bool operator == (const RowGroup & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(total_byte_size == rhs.total_byte_size))
      return false;
    if (!(num_rows == rhs.num_rows))
      return false;
    if (__isset.sorting_columns != rhs.__isset.sorting_columns)
      return false;
    else if (__isset.sorting_columns && !(sorting_columns == rhs.sorting_columns))
      return false;
    return true;
  }
  bool operator != (const RowGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RowGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(RowGroup &a, RowGroup &b);


class TypeDefinedOrder {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  TypeDefinedOrder() {
  }

  virtual ~TypeDefinedOrder() throw() {}


  bool operator == (const TypeDefinedOrder & /* rhs */) const
  {
    return true;
  }
  bool operator != (const TypeDefinedOrder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TypeDefinedOrder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TypeDefinedOrder &a, TypeDefinedOrder &b);

typedef struct _ColumnOrder__isset {
  _ColumnOrder__isset() : TYPE_ORDER(false) {}
  bool TYPE_ORDER;
} _ColumnOrder__isset;

class ColumnOrder {
 public:

  static const char* ascii_fingerprint; // = "2C32A565725135A023CB591D1A993CFD";
  static const uint8_t binary_fingerprint[16]; // = {0x2C,0x32,0xA5,0x65,0x72,0x51,0x35,0xA0,0x23,0xCB,0x59,0x1D,0x1A,0x99,0x3C,0xFD};

  ColumnOrder() {
  }

  virtual ~ColumnOrder() throw() {}

  TypeDefinedOrder TYPE_ORDER;

  _ColumnOrder__isset __isset;

  void __set_TYPE_ORDER(const TypeDefinedOrder& val) {
    TYPE_ORDER = val;
  }

  bool operator == (const ColumnOrder & rhs) const
  {
    if (!(TYPE_ORDER == rhs.TYPE_ORDER))
      return false;
    return true;
  }
  bool operator != (const ColumnOrder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnOrder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnOrder &a, ColumnOrder &b);


class PageLocation {
 public:

  static const char* ascii_fingerprint; // = "C2C41E587DAC84A77A5056A1DC94ED73";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0xC4,0x1E,0x58,0x7D,0xAC,0x84,0xA7,0x7A,0x50,0x56,0xA1,0xDC,0x94,0xED,0x73};

  PageLocation() : offset(0), compressed_page_size(0), first_row_index(0) {
  }

  virtual ~PageLocation() throw() {}

  int64_t offset;
  int32_t compressed_page_size;
  int64_t first_row_index;

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_compressed_page_size(const int32_t val) {
    compressed_page_size = val;
  }

  void __set_first_row_index(const int64_t val) {
    first_row_index = val;
  }

  bool operator == (const PageLocation & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    if (!(compressed_page_size == rhs.compressed_page_size))
      return false;
    if (!(first_row_index == rhs.first_row_index))
      return false;
    return true;
  }
  bool operator != (const PageLocation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PageLocation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(PageLocation &a, PageLocation &b);


class OffsetIndex {
 public:

  static const char* ascii_fingerprint; // = "40179E8A3AF6AD0D7A8603A1CC3544A3";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x17,0x9E,0x8A,0x3A,0xF6,0xAD,0x0D,0x7A,0x86,0x03,0xA1,0xCC,0x35,0x44,0xA3};

  OffsetIndex() {
  }

  virtual ~OffsetIndex() throw() {}

  std::vector<PageLocation>  page_locations;

  void __set_page_locations(const std::vector<PageLocation> & val) {
    page_locations = val;
  }

  bool operator == (const OffsetIndex & rhs) const
  {
    if (!(page_locations == rhs.page_locations))
      return false;
    return true;
  }
  bool operator != (const OffsetIndex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const OffsetIndex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(OffsetIndex &a, OffsetIndex &b);

typedef struct _ColumnIndex__isset {
  _ColumnIndex__isset() : null_counts(false) {}
  bool null_counts;
} _ColumnIndex__isset;

class ColumnIndex {
 public:

  static const char* ascii_fingerprint; // = "8DDCE8A04F663BB8C6545F5725ED49D2";
  static const uint8_t binary_fingerprint[16]; // = {0x8D,0xDC,0xE8,0xA0,0x4F,0x66,0x3B,0xB8,0xC6,0x54,0x5F,0x57,0x25,0xED,0x49,0xD2};

  ColumnIndex() : boundary_order((BoundaryOrder::type)0) {
  }

  virtual ~ColumnIndex() throw() {}

  std::vector<bool>  null_pages;
  std::vector<std::string>  min_values;
  std::vector<std::string>  max_values;
  BoundaryOrder::type boundary_order;
  std::vector<int64_t>  null_counts;

  _ColumnIndex__isset __isset;

  void __set_null_pages(const std::vector<bool> & val) {
    null_pages = val;
  }

  void __set_min_values(const std::vector<std::string> & val) {
    min_values = val;
  }

  void __set_max_values(const std::vector<std::string> & val) {
    max_values = val;
  }

  void __set_boundary_order(const BoundaryOrder::type val) {
    boundary_order = val;
  }

  void __set_null_counts(const std::vector<int64_t> & val) {
    null_counts = val;
    __isset.null_counts = true;
  }

  bool operator == (const ColumnIndex & rhs) const
  {
    if (!(null_pages == rhs.null_pages))
      return false;
    if (!(min_values == rhs.min_values))
      return false;
    if (!(max_values == rhs.max_values))
      return false;
    if (!(boundary_order == rhs.boundary_order))
      return false;
    if (__isset.null_counts != rhs.__isset.null_counts)
      return false;
    else if (__isset.null_counts && !(null_counts == rhs.null_counts))
      return false;
    return true;
  }
  bool operator != (const ColumnIndex &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ColumnIndex & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ColumnIndex &a, ColumnIndex &b);

typedef struct _FileMetaData__isset {
  _FileMetaData__isset() : key_value_metadata(false), created_by(false), column_orders(false) {}
  bool key_value_metadata;
  bool created_by;
  bool column_orders;
} _FileMetaData__isset;

class FileMetaData {
 public:

  static const char* ascii_fingerprint; // = "BC92D7F954E876D10DC8F36F5598374F";
  static const uint8_t binary_fingerprint[16]; // = {0xBC,0x92,0xD7,0xF9,0x54,0xE8,0x76,0xD1,0x0D,0xC8,0xF3,0x6F,0x55,0x98,0x37,0x4F};

  FileMetaData() : version(0), num_rows(0), created_by() {
  }

  virtual ~FileMetaData() throw() {}

  int32_t version;
  std::vector<SchemaElement>  schema;
  int64_t num_rows;
  std::vector<RowGroup>  row_groups;
  std::vector<KeyValue>  key_value_metadata;
  std::string created_by;
  std::vector<ColumnOrder>  column_orders;

  _FileMetaData__isset __isset;

  void __set_version(const int32_t val) {
    version = val;
  }

  void __set_schema(const std::vector<SchemaElement> & val) {
    schema = val;
  }

  void __set_num_rows(const int64_t val) {
    num_rows = val;
  }

  void __set_row_groups(const std::vector<RowGroup> & val) {
    row_groups = val;
  }

  void __set_key_value_metadata(const std::vector<KeyValue> & val) {
    key_value_metadata = val;
    __isset.key_value_metadata = true;
  }

  void __set_created_by(const std::string& val) {
    created_by = val;
    __isset.created_by = true;
  }

  void __set_column_orders(const std::vector<ColumnOrder> & val) {
    column_orders = val;
    __isset.column_orders = true;
  }

  bool operator == (const FileMetaData & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(schema == rhs.schema))
      return false;
    if (!(num_rows == rhs.num_rows))
      return false;
    if (!(row_groups == rhs.row_groups))
      return false;
    if (__isset.key_value_metadata != rhs.__isset.key_value_metadata)
      return false;
    else if (__isset.key_value_metadata && !(key_value_metadata == rhs.key_value_metadata))
      return false;
    if (__isset.created_by != rhs.__isset.created_by)
      return false;
    else if (__isset.created_by && !(created_by == rhs.created_by))
      return false;
    if (__isset.column_orders != rhs.__isset.column_orders)
      return false;
    else if (__isset.column_orders && !(column_orders == rhs.column_orders))
      return false;
    return true;
  }
  bool operator != (const FileMetaData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FileMetaData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FileMetaData &a, FileMetaData &b);

}} // namespace

#endif
