
-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@
--
-- test for BACKUP and RESTORE, part 2
--

cqd TRAF_BACKUP_SKIP_GET_TAGS_OWNER_LOOKUP 'OFF';
drop all backup snapshots, match 'test051%';
cleanup table sch051.t1incr;
cleanup schema sch051a;
cleanup schema sch051;
cleanup schema sch0511;

sh rm -rf /tmp/test051;
cleanup metadata, return details;

log LOG051 clear;

-- should not show any entries
cleanup metadata, check, return details;

cqd traf_blob_as_varchar 'OFF';

-- return error, tag doesn't exist
drop backup snapshot, tag 'test051';

drop schema if exists sch051 cascade;
create schema sch051;
set schema sch051;
cqd traf_restore_parallel '1';

-- precreate tags
backup trafodion, create tags ('test051incr1', 'test051incr2', 'test051incr3');

-- incremental backup tests
drop schema if exists sch0511 cascade;
create schema if not exists sch0511;
showddl schema sch0511;

set schema sch0511;

cqd TRAF_NON_XN_INCR_BACKUP_OPERATION 'ON';
create table loadt(
        colkey int not null,
        colint int not null,
        -- coldate date,
        colnum numeric(11,3),
        colchariso char(11) character set iso88591 not null,
        colcharucs2 char(11) character set ucs2 not null,
        colintn int,
        -- colts timestamp,
        colcharison char(13) character set iso88591,
        colcharucs2n char(13) character set ucs2,
        primary key(colint, colchariso, colcharucs2, colkey)
        ) attributes incremental backup
        ;

load into loadt select
         c1+c2*10+c3*100+c4*1000+c5*10000, --colkey
         c1+c2*10+c3*100+c4*1000+c5*10000, --colint
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as numeric(11,3)), --colnum
        cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(11) character set iso88591), --colchariso
          cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(11) character set ucs2), --colcharucs2
         c1+c2*10+c3*100+c4*1000+c5*10000, --colintn
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(13) character set iso88591), --colvchriso
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(13) character set ucs2) --colvchrucs2
         from (values(1)) t
         transpose 0,1,2,3,4,5,6,7,8,9 as c1
         transpose 0,1,2,3,4,5,6,7,8,9 as c2
         transpose 0,1,2,3,4,5,6,7,8,9 as c3
        transpose 0,1,2,3,4,5,6,7,8,9 as c4
        transpose 0,1,2,3,4,5,6,7,8,9 as c5
           ;

select count(*) from loadt;

-- Should succeed, but will perform regular snapshot since prior doesn't exist
backup trafodion, tag 'test051incr1', table(loadt),incremental,override;
get all backup snapshots, match 'test051%';

-- Add 2 more rows to our incremental table
insert into loadt values(100001,100001,100001.000,'100001','100001',100001,'100001','100001');
insert into loadt values(100002,100002,100002.000,'100002','100002',100002,'100002','100002');
select count(*) from loadt;

-- Reusing the tag.  This is a drop and new incremental backup. Mantis 6542
backup trafodion, tag 'test051incr1', table(loadt),incremental,override;
get all backup snapshots, match 'test051%';

drop table loadt cascade;
restore trafodion, tag 'test051incr1';
select count(*) from loadt;
cqd TRAF_NON_XN_INCR_BACKUP_OPERATION 'OFF';

create table t1incr(a int not null primary key, b int) 
  attribute incremental backup;
showddl t1incr;
alter table t1incr attribute no incremental backup;
showddl t1incr;
alter table t1incr attribute incremental backup;
create table t2noincr(a int);
showddl t2noincr;
create table t2incr(a int not null primary key, b int, c blob) 
  attribute incremental backup;
showddl t2incr;

insert into t2noincr values (1);

insert into t1incr values (1, 10);
explain options 'f' insert into t1incr values (1,10);
insert into t2incr values (1, 10, '50');
backup trafodion, tag 'test051reg1', tables (t1incr, t1incr, t2noincr), override;
upsert into t1incr values (1,10), (2,20), (3,30);
upsert into t2incr values (1,10,'10');
upsert into t2incr values (2,20,'20');
upsert into t2incr values (3,30,'30');
backup trafodion, tag 'test051incr1', tables (t2noincr, t1incr, t2incr), incremental, override;
update t1incr set b = 30 where a = 2;
update t2incr set b = 30 where a = 2;
update t2incr set c = '30' where a = 2;
delete from t1incr where a = 1 and b = 20;
delete from t2incr where a = 1 and b = 20;
-- expect (1, 10), (2, 30), (3, 30)
select * from t1incr;
-- expect (1, 10, '10'), (2, 30, '30'), (3, 30, '30')
select a, b, lobtostring(c,100) from t2incr;
-- Here we have pending mutations for t1incr and t2incr.  When we restore a subset of
-- incremental tables from the incremental backup we should see mutations for t1incr
-- removed, but mutations for t2incr left untouched.  A subsequent backup will prove.
-- Mantis 7197
restore trafodion, tag 'test051incr1', tables (t1incr);
-- expect (1, 10), (2, 20), (3, 30)
select * from t1incr;
-- expect (1, 10, '10'), (2, 30, '30'), (3, 30, '30')
select a, b, lobtostring(c,100) from t2incr;
backup trafodion, tag 'test051incr2', tables (t2noincr, t1incr, t2incr), incremental, override;
update t1incr set b = 40 where a = 2;
update t2incr set b = 40 where a = 2;
update t2incr set c = '40' where a = 2;
restore trafodion, tag 'test051incr2';
-- expect (1, 10), (2, 20), (3, 30)
select * from t1incr;
-- expect (1, 10, '10'), (2, 30, '30'), (3, 30, '30') 
select a, b, lobtostring(c,100) from t2incr;
restore trafodion, tag 'test051reg1';
showddl t1incr;
select * from t1incr;
restore trafodion, tag 'test051incr1';
showddl t1incr;
select * from t1incr;

get all backup snapshots, match 'test051%';
select a, b, lobtostring(c,100) from t2incr;
select a, b, lobtostring(c,100) from t1incr;

create index t1incri1 on t1incr(b);
showddl t1incr;
backup trafodion, tag 'test051incr3', table (t1incr), override;
insert into t1incr values (4,40);
backup trafodion, tag 'test051incr4', table (t1incr), incremental, override;
get all backup snapshots, match 'test051%';
restore trafodion, tag 'test051incr4', table (t1incr);
showddl t1incr;
select * from t1incr;
purgedata t1incr;
backup trafodion, tag 'test051incr5', table (t1incr), incremental, override;
select * from t1incr;
get all backup snapshots, match 'test051%';

-- incremental backup error cases
drop index t1incri1;
delete with no rollback from t1incr;
upsert using load into t1incr values (5,50);
create volatile table t (a int) attribute incremental backup;

-- cannot drop, dependent objects exist
drop backup snapshot, tag 'test051reg1';

-- Should restore t1incr
restore trafodion, tag 'test051reg1';

select * from t1incr;

-- need to drop incr backup first as cascade option doesn't work yet. TBD.
drop backup snapshot, tag 'test051incr5';
drop backup snapshot, tag 'test051incr4';
drop backup snapshot, tag 'test051incr3';
drop backup snapshot, tag 'test051incr2';
drop backup snapshot, tag 'test051incr1';
drop backup snapshot, tag 'test051reg1', force, cascade;

-- incr backup with cdc
drop table if exists t1incr6;
create table t1incr6 (i int, j int) attribute incremental backup;
backup trafodion, tag 'test051reg1', tables(t1incr6), override;
upsert into t1incr6 values (1,1), (2, 2), (1, 2), (2, 1);
update t1incr6 set i = 5 where j = 2;
delete from t1incr6 where i = 1;
select * from t1incr6 order by 1,2;
backup trafodion, tag 'test051incr1', tables(t1incr6), incremental, override;
restore trafodion, tag 'test051incr1', tables(t1incr6);
select * from t1incr6 order by 1,2;

drop backup snapshot, tag 'test051incr1';
drop backup snapshot, tag 'test051reg1', force, cascade;

--M7900
create table test3(a int, b varchar(20)) attribute incremental backup;
backup trafodion, tag 'test051reg1', table(test3),override;
-- expect 0 rows
select * from test3;
insert into test3 values(1,'inc1');
backup trafodion, tag 'test051incr1', table(test3),incremental,override;
alter table test3 add column addco11 varchar(20);
insert into test3 values(2,'inc2','inc2');
select * from test3;
backup trafodion, tag 'test051incr2', table(test3),incremental,override;
get all backup tags, show details, match 'test051%';
delete from test3;
restore trafodion, tag 'test051incr1';
--expect 1, 'inc1'
select * from test3;
insert into test3 values(1,'inc3'),(2,'inc3');
select * from test3;
backup trafodion, tag 'test051incr3', table(test3),incremental,override;
delete from test3;
restore trafodion, tag 'test051incr3';
-- expect
--        1, 'inc1'
--        1, 'inc3'
--        2, 'inc3'
select * from test3;
restore trafodion, tag 'test051incr2';
select * from test3;

-- end state
get all backup snapshots, match 'test051%';
get all backup tags, show details, match 'test051%';
drop all backup snapshots, match 'test051%';
get all backup tags, show details, match 'test051%';
get all backup metadata, match 'test051%';

log;

-- clean up

