
-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@
--
-- test for BACKUP and RESTORE, part 2
--

cqd TRAF_BACKUP_SKIP_GET_TAGS_OWNER_LOOKUP 'OFF';
drop all backup snapshots, match 'test055%';
cleanup table sch055.t1incr;
cleanup schema sch055a;
cleanup schema sch055;
cleanup schema sch0551;

sh rm -rf /tmp/test055;
cleanup metadata, return details;

log LOG055 clear;

-- should not show any entries
cleanup metadata, check, return details;

cqd traf_blob_as_varchar 'OFF';

-- return error, tag doesn't exist
drop backup snapshot, tag 'test055';

drop schema if exists sch055 cascade;
create schema sch055;
set schema sch055;
cqd traf_restore_parallel '1';

-- precreate tags
backup trafodion, create tags ('test055incr1', 'test055incr2', 'test055incr3');

-- incremental backup tests
drop schema if exists sch0551 cascade;
create schema if not exists sch0551;
showddl schema sch0551;

set schema sch0551;

cqd TRAF_NON_XN_INCR_BACKUP_OPERATION 'ON';
create table loadt(
        colkey int not null,
        colint int not null,
        -- coldate date,
        colnum numeric(11,3),
        colchariso char(11) character set iso88591 not null,
        colcharucs2 char(11) character set ucs2 not null,
        colintn int,
        -- colts timestamp,
        colcharison char(13) character set iso88591,
        colcharucs2n char(13) character set ucs2,
        primary key(colint, colchariso, colcharucs2, colkey)
        ) attributes incremental backup
        ;

load into loadt select
         c1+c2*10+c3*100+c4*1000+c5*10000, --colkey
         c1+c2*10+c3*100+c4*1000+c5*10000, --colint
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as numeric(11,3)), --colnum
        cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(11) character set iso88591), --colchariso
          cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(11) character set ucs2), --colcharucs2
         c1+c2*10+c3*100+c4*1000+c5*10000, --colintn
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(13) character set iso88591), --colvchriso
         cast(c1+c2*10+c3*100+c4*1000+c5*10000 as char(13) character set ucs2) --colvchrucs2
         from (values(1)) t
         transpose 0,1,2,3,4,5,6,7,8,9 as c1
         transpose 0,1,2,3,4,5,6,7,8,9 as c2
         transpose 0,1,2,3,4,5,6,7,8,9 as c3
        transpose 0,1,2,3,4,5,6,7,8,9 as c4
        transpose 0,1,2,3,4,5,6,7,8,9 as c5
           ;

select count(*) from loadt;

-- Add 2 more rows to our incremental table
insert into loadt values(100001,100001,100001.000,'100001','100001',100001,'100001','100001');
insert into loadt values(100002,100002,100002.000,'100002','100002',100002,'100002','100002');
select count(*) from loadt;

drop table loadt cascade;
select count(*) from loadt;
cqd TRAF_NON_XN_INCR_BACKUP_OPERATION 'OFF';

create table t1incr(a int not null primary key, b int) 
  attribute incremental backup;
showddl t1incr;
alter table t1incr attribute no incremental backup;
showddl t1incr;
alter table t1incr attribute incremental backup;
create table t2noincr(a int);
showddl t2noincr;
create table t2incr(a int not null primary key, b int) 
  attribute incremental backup;
showddl t2incr;

insert into t2noincr values (1);

insert into t1incr values (1, 10);
explain options 'f' insert into t1incr values (1,10);
insert into t2incr values (1, 10);
upsert into t1incr values (1,10), (2,20), (3,30);
upsert into t2incr values (1,10), (2,20), (3,30);
update t1incr set b = 30 where a = 2;
update t2incr set b = 30 where a = 2;
delete from t1incr where a = 1 and b = 20;
delete from t2incr where a = 1 and b = 20;
-- expect (1, 10), (2, 30), (3, 30)
select * from t1incr;
-- expect (1, 10), (2, 30), (3, 30)
select * from t2incr;
update t1incr set b = 40 where a = 2;
update t2incr set b = 40 where a = 2;
-- expect (1, 10), (2, 40), (3, 30)
select * from t1incr;

-- expect (1, 10), (2, 40), (3, 30)
select * from t2incr;

create index t1incri1 on t1incr(b);
showddl t1incr;
insert into t1incr values (4,40);
select * from t1incr;
purgedata t1incr;

-- incr backup with cdc
drop table if exists t1incr6;
create table t1incr6 (i int, j int) attribute incremental backup;
upsert into t1incr6 values (1,1), (2, 2), (1, 2), (2, 1);
update t1incr6 set i = 5 where j = 2;
delete from t1incr6 where i = 1;

-- there should not be any locks.
get all locked objects;

-- should not be any orphans in metadata at this point
cleanup metadata, check, return details;

-- need to drop incr backup first as cascade option doesn't work yet. TBD.
drop backup snapshot, tag 'test055incr1';
drop backup snapshot, tag 'test055reg1', force, cascade;

-- schema of restored table doesn't exist. Return error.TBD. mantis 6317
create schema if not exists sch055a namespace 'TRAF_regr' incremental backup;
create table sch055a.t (a int);
backup trafodion, tag 'test055reg1', table (sch055a.t), override;
restore trafodion, tag 'test055reg1', table (sch055a.t), show objects;
drop schema sch055a cascade;
restore trafodion, tag 'test055reg1', table (sch055a.t), show objects;

restore trafodion, tag 'test055reg1', table (sch055a.t);
showddl schema sch055a;
cleanup backup, tag 'test055reg1';

create schema if not exists sch055a namespace 'TRAF_regr' incremental backup;
set schema sch055a;

-- full database backup and restore
create table tab2(c1 int,c2 int,c3 int,c4 int,c5 int, c6 int, c7 int, c8 int, c9 int, c10 int,c11 char(2),c12 char(2));
insert into tab2 values(5,5,5,5,5,5,5,5,5,5,'5','5');
insert into tab2 values(6,6,6,6,6,6,6,6,6,6,'6','6');
backup trafodion, tag 'test055fulldb', override;
insert into tab2 values(7,7,7,7,7,7,7,7,7,7,'7','7');
insert into tab2 values(8,8,8,8,8,8,8,8,8,8,'8','8');
backup trafodion, tag 'test055fulldbincr',incremental, override;
get all backup snapshots, match 'test055%';
restore trafodion, tag 'test055fulldb', tables(tab2);
select * from tab2;
restore trafodion, tag 'test055fulldbincr', tables (tab2);
select * from tab2;
drop backup snapshot, tag 'test055fulldbincr';
drop backup snapshot, tag 'test055fulldb', force, cascade;

-- restore after alter rename should cleanup. mantis 6897.
set schema sch055a;
create table if not exists tabc (c1 int, c2 varchar(20));
insert into tabc values(0,'traf');
backup trafodion, tag 'test055reg1', table(tabc), override;
insert into tabc values (1, 'inc1');
drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC_OLD";
get all hbase objects, match 'TRAF_regr:TRAFODION.SCH055A.TABC_OLD';
alter table tabc rename to tabc_old;
alter table tabc_old generate stored descriptor;
invoke tabc;
invoke tabc_old;
get all hbase objects, match 'TRAF_regr:TRAFODION.SCH055A.TABC_OLD';
get tables;
restore trafodion, tag 'test055reg1';

-- should not show TABC_OLD
get all hbase objects, match 'TRAF_regr:TRAFODION.SCH055A.TABC_OLD';
get tables;
drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC_OLD";

-- incr backup restore test. mantis-?
set schema sch055a;
drop table if exists tabc;
create table if not exists tabc (c1 int, c2 varchar(20));
insert into tabc values(0,'traf');
backup trafodion, tag 'test055reg1', table(tabc), override;
insert into tabc values (1, 'inc1');
backup trafodion, tag 'test055incr1', table(tabc), incremental, override;

-- keyword override will drop all dependent tags when backup type is REGULAR
-- backup tag 'test055incr1' should be droped
backup trafodion, tag 'test055reg1', table(tabc), override;

alter table tabc rename to tabc_old;
alter table tabc_old generate stored descriptor;

create table tabc(a int, b int, c varchar(20));
insert into tabc values(0,0,'traf');
insert into tabc values(1,1,'inc1');
backup trafodion, tag 'test055incr3', table(tabc), incremental, override;
get all backup snapshots, match 'test055%';

restore trafodion, tag 'test055incr3', table(tabc);
backup trafodion, tag 'test055incr3', table(tabc),incremental, override;

get all backup snapshots, match 'test055%';
restore trafodion, tag 'test055incr3', table(tabc);

select * from tabc;
get tables;
delete from tabc;
restore trafodion, tag 'test055incr3';
get tables;
select * from tabc;
-- incrmental backup tag 'test055incr1' not exists
restore trafodion, tag 'test055incr1';
-- expect (0,0,'traf'), (1,1,'inc1')
select * from tabc;

-- cleanup TABC_OLD
drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC_OLD";

-- incr backup restore test when table renamed and 
-- then renamed back to the original. mantis-7202
-- This needs to be enabled at a later date.
-- Now causes Too many zookeeper connections and
-- CorruptSnapshotExceptions
-- drop backup snapshot, tag 'test055incr1';
-- drop backup snapshot, tag 'test055reg1';
-- drop table if exists tabc;
-- drop table if exists tabc_new;
-- drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC";
-- drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC_NEW";
-- create table tabc(a int, b varchar(20)) attribute incremental backup;
-- insert into tabc values(1,'base'),(2,'base');
-- --regular backup for table
-- backup trafodion, tag 'test055tabc_bkbase1';
-- insert into  tabc values(1,'inc1'),(2,'inc1');
-- backup trafodion, tag 'test055tabc_incbk1', incremental, override;
-- --alter rename
-- alter table tabc rename to tabc_new;
-- alter table tabc_new generate stored descriptor;

-- cleanup old table
-- backup trafodion, tag 'test055tabc_new_bkbase1';
-- get tables;
-- insert into tabc_new values(10,'inc2'),(11,'inc2');
-- backup trafodion, tag 'test055tabc_new_incbk2',incremental, override;

-- --expect (1,'base'),(2,'base'),(1,'inc1'),(2,'inc1'),(10,'inc2'),(11,'inc2')
-- select * from tabc_new;

-- alter table tabc_new rename to tabc;
-- alter table tabc generate stored descriptor;

-- cleanup old table
-- --drop hbase table "TRAF_regr:TRAFODION.SCH055A.TABC_NEW";
-- backup trafodion, tag 'test055tabc_incbk3',incremental, override;
-- insert into tabc values(20,'inc3'),(21,'inc3');

-- --expect (1,'base'),(2,'base'),(1,'inc1'),(2,'inc1'),(10,'inc2'),(11,'inc2'),(20,'inc3'),(21,'inc3')
-- select * from tabc;

-- backup trafodion, tag 'test055tabc_incbk3',incremental, override;
-- insert into tabc values(30,'inc4'),(31,'inc4');

-- --expect (1,'base'),(2,'base'),(1,'inc1'),(2,'inc1'),(10,'inc2'),(11,'inc2'),(20,'inc3'),(21,'inc3'),(30,'inc4'),(31,'inc4')
-- select * from  tabc;

-- drop table tabc cascade;
-- restore trafodion, tag 'test055tabc_incbk1';
-- --expect (1,'base'),(2,'base'),(1,'inc1'),(2,'inc1')
-- select * from tabc;
-- drop table tabc cascade;

-- restore trafodion, tag 'test055tabc_new_incbk2';
-- --expect(1,'base'),(2,'base'),(1,'inc1'),(2,'inc1'),(10,'inc2'),(11,'inc2')
-- select * from tabc_new;
-- drop table tabc_new cascade;

-- restore trafodion, tag 'test055tabc_incbk3';
-- --- SQL operation complete.
-- --expect (1,'base'),(2,'base'),(1,'inc1'),(2,'inc1'),(10,'inc2'),(11,'inc2'),(20,'inc3'),(21,'inc3')
-- select * from tabc;

-- 'Alter add' after restore - Mantis 7475
delete from tabc;
-- sql return error, table tabc have 3 columns
insert into tabc values(0,'base');
backup trafodion, tag 'test055_altadd_regbk', tables(tabc),override;

--inc1: alter add
alter table tabc add column c3 varchar(20);
showddl tabc;

--incbk1
insert into tabc values(1,1,'inc1','inc1');
--expect (1,1,'inc1','inc1')
select * from tabc;
backup trafodion, tag 'test055incr1', tables(tabc), incremental,override;

--inc2
insert into tabc values(2,2,'inc2','inc2');
--expect (1,1,'inc1','inc1'),(2,2,'inc2','inc2')
select * from tabc;
backup trafodion, tag 'test055incr2', tables(tabc), incremental,override;

--incbk3
alter table tabc attribute no incremental backup;
-- aflter add column tabc has 5 columns
alter table tabc add column c4 char(8);
insert into tabc values(3,3,'no-inc3','no-inc3','no-inc3');
--expect (1,1,'inc1','inc1',?),(2,2,'inc2','inc2',?),(3,3,'no-inc3','no-inc3','no-inc3')
select * from tabc;
backup trafodion, tag 'test055incr3', tables(tabc), incremental,override;

drop table tabc cascade;
--restore test055tabc_incbk2
-- This should accomplish 2 things.  It should restore a version of tabc
-- that has the incremental backup attribute and it should exclude mutations
-- from test055tabc_incbk4 from future backup operations
restore trafodion, tag 'test055incr2';
showddl tabc;
--expect (1,1,'inc1','inc1'),(2,2,'inc2','inc2')
select * from tabc;

--incbk4
backup trafodion, tag 'test055incr4', tables(tabc), incremental,override;
delete from tabc;
insert into tabc values(3,3,'inc4','inc4');
select * from tabc;

--incbk5
backup trafodion, tag 'test055incr5', tables(tabc), incremental,override;
drop table tabc cascade;

--restore incbk5
restore trafodion, tag 'test055incr5';
showddl tabc;
select * from tabc;

-- end state
get all backup snapshots, match 'test055%';
get all backup tags, show details, match 'test055%';
drop all backup snapshots, match 'test055%';
get all backup tags, show details, match 'test055%';
get all backup metadata, match 'test055%';

log;

-- clean up

