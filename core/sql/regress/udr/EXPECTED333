>>obey TEST333(setup);
>>
>>CREATE TABLE orders1 (item VARCHAR(100),description VARCHAR(100));

--- SQL operation complete.
>>INSERT INTO orders1 VALUES('aitem','adescription');

--- 1 row(s) inserted.
>>INSERT INTO orders1 VALUES('bitem','bdescription');

--- 1 row(s) inserted.
>>
>>CREATE TABLE orders2 (item VARCHAR(100),description VARCHAR(100));

--- SQL operation complete.
>>INSERT INTO orders2 VALUES('2aitem','2adescription');

--- 1 row(s) inserted.
>>INSERT INTO orders2 VALUES('2bitem','2bdescription');

--- 1 row(s) inserted.
>>
>>create table emp(
+>  employee_id    decimal(6),
+>  first_name     VARCHAR(20),
+>  last_name      VARCHAR(25),
+>  email          VARCHAR(25),
+>  phone_decimal   VARCHAR(20),
+>  hire_date      DATE,
+>  job_id         VARCHAR(10),
+>  salary         decimal(8,2),
+>  commission_pct decimal(2,2),
+>  manager_id     decimal(6),
+>  department_id  decimal(4)
+>);

--- SQL operation complete.
>>insert into emp values (198,'Donald','OConnell','DOCONNEL','650.507.9833',date '2007-06-21','SH_CLERK',2600,null,'124','50');

--- 1 row(s) inserted.
>>insert into emp values (199,'Douglas','Grant','DGRANT','650.507.9844',date '2008-01-13','SH_CLERK',3000,null,'124','50');

--- 1 row(s) inserted.
>>
>>CREATE TABLE seabase.tb_test(a varchar2(10));

--- SQL operation complete.
>>INSERT INTO seabase.tb_test values('test');

--- 1 row(s) inserted.
>>
>>CREATE TABLE tb_hostcode(s VARCHAR2(20), s2 VARCHAR2(20));

--- SQL operation complete.
>>insert into tb_hostcode values('ss','sss');

--- 1 row(s) inserted.
>>
>>CREATE TABLE test_results(RESULTS VARCHAR(80));

--- SQL operation complete.
>>
>>CREATE TABLE table_t1(t int);

--- SQL operation complete.
>>CREATE TABLE table_t2(t int);

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_defining_variables() AS
+>//BEGIN
  DECLARE code CHAR(10) = 'code';
  DECLARE status, status2 INT DEFAULT 1;
  DECLARE limit1 INT DEFAULT 100;
  DECLARE num INT := 1;
  DECLARE num2 INT = 2;
  PRINT code;
  PRINT status;
  PRINT status2;
  PRINT limit1;
  PRINT num;
  PRINT num2;
END//;

--- SQL operation complete.
>>CALL test_defining_variables();

CODE
----

code

--- 1 row(s) selected.

STATUS
------

     1

--- 1 row(s) selected.

STATUS2
-------

      1

--- 1 row(s) selected.

LIMIT1
------

   100

--- 1 row(s) selected.

NUM   
------

     1

--- 1 row(s) selected.

NUM2  
------

     2

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE or replace PROCEDURE test_defining_variables2() AS //
DECLARE
  SUBstr varchar2(20) := 'REMark';
  SUBSTr1 varchar2(20) := 'REMArk';
  "SUBSTR2" varchar2(20) := 'REMARK';
  "SUBstr2" varchar2(20) := 'Remark';
  "SUBstr" varchar2(20) := 'remark';
BEGIN
  print SUBstr1;
  print "SUBSTR2";
  print "SUBstr2"; 
  print SUBSTR1;
  print "SUBSTR";
  print "SUBstr";
END//;

--- SQL operation complete.
>>CALL test_defining_variables2();

SUBSTR1
-------

REMArk 

--- 1 row(s) selected.

SUBSTR2
-------

REMARK 

--- 1 row(s) selected.

SUBstr2
-------

Remark 

--- 1 row(s) selected.

SUBSTR1
-------

REMArk 

--- 1 row(s) selected.

SUBSTR
------

REMark

--- 1 row(s) selected.

SUBstr
------

remark

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_flow_control() AS
+>//BEGIN
        DECLARE Flow_Control_count INT DEFAULT 3;
        WHILE 1=1 BEGIN
          SET Flow_Control_count = Flow_Control_count - 1;
          PRINT Flow_Control_count;
          IF Flow_Control_count = 0 
            BREAK;
          END;
        END;
END//;

--- SQL operation complete.
>>CALL test_flow_control();

FLOW_CONTROL_COUNT
------------------

                 2

--- 1 row(s) selected.

FLOW_CONTROL_COUNT
------------------

                 1

--- 1 row(s) selected.

FLOW_CONTROL_COUNT
------------------

                 0

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_exit_when2() AS
+>//BEGIN
        <<lbl>>
        WHILE 1=1 LOOP
          <<lbl1>>
          WHILE 1=1 LOOP
          	PRINT 'If not print error then correct';
		        EXIT lbl;
          END LOOP;
          PRINT 'error';
        END LOOP;
END//;

--- SQL operation complete.
>>CALL test_exit_when2();

(EXPR)                         
-------------------------------

If not print error then correct

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>
>>CREATE PROCEDURE test_exit_when() AS
+>//BEGIN
        DECLARE count2 INT DEFAULT 3;
        WHILE count2 > 0 LOOP
          count2 := count2 - 1;
          PRINT count2; 
          EXIT WHEN count2 = 0;
        END LOOP;
END//;

--- SQL operation complete.
>>CALL test_exit_when();

COUNT2
------

     2

--- 1 row(s) selected.

COUNT2
------

     1

--- 1 row(s) selected.

COUNT2
------

     0

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_for_cursorloop() AS
+>//BEGIN
        FOR ordersrows IN (
            SELECT item, description
            FROM orders1
            WHERE item LIKE '%a%')
        LOOP
          PRINT ordersrows.item;
          PRINT ordersrows.description;
        END LOOP;
END//;

--- SQL operation complete.
>>CALL test_for_cursorloop();

ORDERSROWS.ITEM
---------------

aitem          

--- 1 row(s) selected.

ORDERSROWS.DESCRIPTION
----------------------

adescription          

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_for() AS
+>//BEGIN
        FOR i IN 1..10 LOOP
            PRINT i;
        END LOOP;

        FOR i IN REVERSE 1..10 LOOP
            PRINT i;
        END LOOP;

        FOR i IN 1..10 BY 2 LOOP
            PRINT I;
        END LOOP;
END//;

--- SQL operation complete.
>>CALL test_for();

I     
------

     1

--- 1 row(s) selected.

I     
------

     2

--- 1 row(s) selected.

I     
------

     3

--- 1 row(s) selected.

I     
------

     4

--- 1 row(s) selected.

I     
------

     5

--- 1 row(s) selected.

I     
------

     6

--- 1 row(s) selected.

I     
------

     7

--- 1 row(s) selected.

I     
------

     8

--- 1 row(s) selected.

I     
------

     9

--- 1 row(s) selected.

I     
------

    10

--- 1 row(s) selected.

I     
------

    10

--- 1 row(s) selected.

I     
------

     9

--- 1 row(s) selected.

I     
------

     8

--- 1 row(s) selected.

I     
------

     7

--- 1 row(s) selected.

I     
------

     6

--- 1 row(s) selected.

I     
------

     5

--- 1 row(s) selected.

I     
------

     4

--- 1 row(s) selected.

I     
------

     3

--- 1 row(s) selected.

I     
------

     2

--- 1 row(s) selected.

I     
------

     1

--- 1 row(s) selected.

I     
------

     1

--- 1 row(s) selected.

I     
------

     3

--- 1 row(s) selected.

I     
------

     5

--- 1 row(s) selected.

I     
------

     7

--- 1 row(s) selected.

I     
------

     9

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_ifelse() AS
+>//BEGIN
        DECLARE ifelse_code INT;
        DECLARE state VARCHAR(10) = 'CA';
        IF state = 'CA' THEN
          ifelse_code := 1;
        ELSIF state = 'NY' THEN
          ifelse_code := 2;
        ELSIF state = 'MA' THEN
          ifelse_code := 3;
        ELSE
          ifelse_code := 5;
        END IF;
        PRINT ifelse_code;
END//;

--- SQL operation complete.
>>CALL test_ifelse();

IFELSE_CODE
-----------

          1

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_leave() AS
+>//BEGIN
        DECLARE LEAVE_count INT = 3;
        lbl:
        WHILE LEAVE_count > 0 DO
          SET LEAVE_count = LEAVE_count - 1;
          PRINT LEAVE_count;
          IF LEAVE_count = 0 THEN
            LEAVE lbl;
          END IF;
        END WHILE;
END//;

--- SQL operation complete.
>>CALL test_leave();

LEAVE_COUNT
-----------

          2

--- 1 row(s) selected.

LEAVE_COUNT
-----------

          1

--- 1 row(s) selected.

LEAVE_COUNT
-----------

          0

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_while() AS
+>//BEGIN
        DECLARE WHILE_count INT = 3;
        WHILE WHILE_count > 0 BEGIN
          WHILE_count := WHILE_count - 1;
          PRINT WHILE_count;
        END;
END//;

--- SQL operation complete.
>>CALL test_while();

WHILE_COUNT
-----------

          2

--- 1 row(s) selected.

WHILE_COUNT
-----------

          1

--- 1 row(s) selected.

WHILE_COUNT
-----------

          0

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_close() AS
+>//BEGIN
        DECLARE close_id VARCHAR(100);
        DECLARE close_cur CURSOR FOR 'SELECT item FROM orders1';
        OPEN close_cur;
        FETCH close_cur INTO close_id;
        PRINT close_id;
        CLOSE close_cur;
END//;

--- SQL operation complete.
>>CALL test_close();

CLOSE_ID
--------

aitem   

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_cursor_attributes() AS
+>//BEGIN
        DECLARE CURSOR cursor_attributes_c1 IS SELECT item FROM orders1 LIMIT 1;
        DECLARE cursor_attributes_v1 VARCHAR(100);
	      DECLARE CONTINUE HANDLER FOR NOT FOUND
                PRINT 'Wrong number of rows';
        BEGIN
          OPEN cursor_attributes_c1;
          IF cursor_attributes_c1%ISOPEN THEN
            PRINT 'Cursor open';
          END IF; 
          FETCH cursor_attributes_c1 INTO cursor_attributes_v1;
          IF cursor_attributes_c1%FOUND THEN
            PRINT 'Row found';
          END IF;  
          FETCH cursor_attributes_c1 INTO cursor_attributes_v1;
          IF cursor_attributes_c1%NOTFOUND THEN
            PRINT 'Row not found';
          END IF;  
          CLOSE cursor_attributes_c1; 
        END;
END//;

--- SQL operation complete.
>>CALL test_cursor_attributes();

(EXPR)     
-----------

Cursor open

--- 1 row(s) selected.

(EXPR)   
---------

Row found

--- 1 row(s) selected.

(EXPR)       
-------------

Row not found

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_fetch() AS
+>//BEGIN
        DECLARE fetch_tabname VARCHAR DEFAULT 'orders1';
        DECLARE fetch_item VARCHAR(100);
        DECLARE fetch_cur CURSOR FOR 'SELECT item FROM ' || fetch_tabname;
        OPEN fetch_cur;
        FETCH fetch_cur INTO fetch_item;
        WHILE SQLCODE=0 THEN
          PRINT fetch_item;
          FETCH fetch_cur INTO fetch_item;
        END WHILE;
        CLOSE fetch_cur;
END//;

--- SQL operation complete.
>>CALL test_fetch();

FETCH_ITEM
----------

aitem     

--- 1 row(s) selected.

FETCH_ITEM
----------

bitem     

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_dynamicSQL() AS
+>//BEGIN
        DECLARE DynamicSQL_cnt INT;
        EXECUTE 'SELECT COUNT(*) FROM orders1' INTO DynamicSQL_cnt;
        PRINT DynamicSQL_cnt;
        DECLARE tabname VARCHAR(100) DEFAULT 'tab1';
        EXECUTE IMMEDIATE 'CREATE TABLE ' || tabname || ' (c1 INT)';
		    INSERT INTO tab1 VALUES(1);
	      EXEC 'SELECT COUNT(*) FROM orders1' INTO DynamicSQL_cnt;
	      PRINT DynamicSQL_cnt;
END//;

--- SQL operation complete.
>>CALL test_dynamicSQL();

DYNAMICSQL_CNT
--------------

             2

--- 1 row(s) selected.

DYNAMICSQL_CNT
--------------

             2

--- 1 row(s) selected.

--- SQL operation complete.
>>SELECT * FROM tab1;

C1         
-----------

          1

--- 1 row(s) selected.
>>
>>CREATE PROCEDURE test_exception_block() AS
+>//BEGIN
        DECLARE EXCEPTION_BLOCK_v VARCHAR(200);
        BEGIN
          OPEN EXCEPTION_BLOCK_cur FOR 'SELECT c1 FROM t1';
          FETCH EXCEPTION_BLOCK_cur INTO EXCEPTION_BLOCK_v;
          CLOSE EXCEPTION_BLOCK_cur;
        EXCEPTION WHEN OTHERS THEN
          PRINT 'Error';
        END;
END//;

--- SQL operation complete.
>>CALL test_exception_block();

(EXPR)
------

Error 

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_rowtype_type () AS
+>//BEGIN
        DECLARE ROWTYPE_TYPE_v orders1%ROWTYPE;

        SELECT * INTO ROWTYPE_TYPE_v FROM orders1 LIMIT 1;
        PRINT ROWTYPE_TYPE_v.item;
        PRINT ROWTYPE_TYPE_v.description;

        DECLARE ROWTYPE_TYPE_v1 orders1%ROWTYPE;
        DECLARE CURSOR ROWTYPE_TYPE_c1 IS SELECT * FROM orders1;
        OPEN ROWTYPE_TYPE_c1;
        FETCH ROWTYPE_TYPE_c1 INTO ROWTYPE_TYPE_v1;
        PRINT ROWTYPE_TYPE_v1.item;
        PRINT ROWTYPE_TYPE_v1.description;
        CLOSE ROWTYPE_TYPE_c1;

        DECLARE ROWTYPE_TYPE_v2 orders1%ROWTYPE;
        FOR ROWTYPE_TYPE_v2 IN (SELECT * FROM orders1)
        LOOP
          PRINT ROWTYPE_TYPE_v2.item;
          PRINT ROWTYPE_TYPE_v2.description;
        END LOOP;

        DECLARE ROWTYPE_TYPE_v3 orders1%ROWTYPE;
        EXECUTE IMMEDIATE 'SELECT * FROM orders1 LIMIT 1' INTO ROWTYPE_TYPE_v3;
        PRINT ROWTYPE_TYPE_v3.item;
        PRINT ROWTYPE_TYPE_v3.description;

        DECLARE ROWTYPE_TYPE_i orders1.item%TYPE;
        SELECT item INTO ROWTYPE_TYPE_i FROM orders1 LIMIT 1;
        PRINT ROWTYPE_TYPE_i;
END//;

--- SQL operation complete.
>>CALL test_rowtype_type();

ROWTYPE_TYPE_V.ITEM
-------------------

aitem              

--- 1 row(s) selected.

ROWTYPE_TYPE_V.DESCRIPTION
--------------------------

adescription              

--- 1 row(s) selected.

ROWTYPE_TYPE_V1.ITEM
--------------------

aitem               

--- 1 row(s) selected.

ROWTYPE_TYPE_V1.DESCRIPTION
---------------------------

adescription               

--- 1 row(s) selected.

ROWTYPE_TYPE_V2.ITEM
--------------------

aitem               

--- 1 row(s) selected.

ROWTYPE_TYPE_V2.DESCRIPTION
---------------------------

adescription               

--- 1 row(s) selected.

ROWTYPE_TYPE_V2.ITEM
--------------------

bitem               

--- 1 row(s) selected.

ROWTYPE_TYPE_V2.DESCRIPTION
---------------------------

bdescription               

--- 1 row(s) selected.

ROWTYPE_TYPE_V3.ITEM
--------------------

aitem               

--- 1 row(s) selected.

ROWTYPE_TYPE_V3.DESCRIPTION
---------------------------

adescription               

--- 1 row(s) selected.

ROWTYPE_TYPE_I
--------------

aitem         

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_temp() as
+>//begin
SET hplsql.temp.tables = managed;
DECLARE TEMPORARY TABLE temp(  
   c1 INT,
   c2 varchar(10));
INSERT INTO temp SELECT 1, 'A' FROM dual;
SELECT * FROM temp;
end//;

--- SQL operation complete.
>>call test_temp();

C1           C2        
-----------  ----------

          1  A         

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_temp() as
+>//begin
SET hplsql.temp.tables = managed; 
CREATE LOCAL TEMPORARY TABLE temp1
(
   c1 INT,
   c2 varchar(10)
);
 
INSERT INTO temp1 SELECT 1, 'A' FROM dual;
 
SELECT * FROM temp1;
end//;

--- SQL operation complete.
>>call test_temp();

C1           C2        
-----------  ----------

          1  A         

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_schema() AS
+>//BEGIN
CREATE SCHEMA T_SCHEMA;
END//;

--- SQL operation complete.
>>CALL test_schema();

--- SQL operation complete.
>>
>>CREATE PROCEDURE TEST_DESC() AS
+>//BEGIN
DESC orders1;
DESCRIBE orders2;
END//;

--- SQL operation complete.
>>CALL test_desc();

--- SQL operation complete.
>>
>>create procedure test_null() AS
+>//BEGIN
  	null;
end//;

--- SQL operation complete.
>>CALL test_null();

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_drop_table_1() AS//
BEGIN
DROP TABLE IF EXISTS table_t1;
SELECT * FROM table_t1;
END//;

--- SQL operation complete.
>>CALL test_drop_table_1();

*** ERROR[11220] A Java method completed with an uncaught java.sql.SQLException with invalid SQLSTATE. The uncaught exception had a SQLCODE of -4082 and SQLSTATE of 42000. Details: java.sql.SQLException: *** ERROR[4082] Object TRAFODION.SCH.TABLE_T1 does not exist or is inaccessible.

*** ERROR[11224] The Java virtual machine raised an exception. Details: java.sql.SQLException: *** ERROR[8822] The statement was not prepared.

--- SQL operation failed with errors.
>>
>>CREATE PROCEDURE test_drop_table_2() AS//
BEGIN
DROP TABLE table_t2;
SELECT * FROM table_t2;
END//;

--- SQL operation complete.
>>CALL test_drop_table_2();

*** ERROR[11220] A Java method completed with an uncaught java.sql.SQLException with invalid SQLSTATE. The uncaught exception had a SQLCODE of -4082 and SQLSTATE of 42000. Details: java.sql.SQLException: *** ERROR[4082] Object TRAFODION.SCH.TABLE_T2 does not exist or is inaccessible.

*** ERROR[11224] The Java virtual machine raised an exception. Details: java.sql.SQLException: *** ERROR[8822] The statement was not prepared.

--- SQL operation failed with errors.
>>
>>CREATE PROCEDURE test_use() AS
+>//BEGIN
        use seabase;
        create table t_test_use(a int);
        insert into t_test_use values(1);
        select * from trafodion.seabase.t_test_use;
END//;

--- SQL operation complete.
>>CALL test_use();

A          
-----------

          1

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_cast () AS
+>//BEGIN
		PRINT CAST('Abc' AS CHAR(1));
		PRINT CAST(TIMESTAMP '2015-03-12 10:58:34.111' AS CHAR(50));
		PRINT CAST('123' AS INT);
		PRINT CAST('1.23' AS FLOAT);
		PRINT CAST('1.23' AS DOUBLE);
		PRINT CAST('1.23' AS DECIMAL(10,4));
END//;

--- SQL operation complete.
>>CALL test_cast();

(EXPR)
------

A     

--- 1 row(s) selected.

(EXPR)                 
-----------------------

2015-03-12 10:58:34.111

--- 1 row(s) selected.

(EXPR)
------

   123

--- 1 row(s) selected.

(EXPR) 
-------

   1.23

--- 1 row(s) selected.

(EXPR) 
-------

   1.23

--- 1 row(s) selected.

(EXPR)      
------------

        1.23

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_char () AS
+>//BEGIN
		PRINT CHAR(66);
END//;

--- SQL operation complete.
>>CALL test_char();

(EXPR)
------

66    

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_coalesce () AS
+>//BEGIN
        PRINT COALESCE(1, 2, 3);
        PRINT COALESCE(NULL, 1, 2, 3);
        PRINT COALESCE(NULL, NULL, 1, 2, 3);
END//;

--- SQL operation complete.
>>CALL test_coalesce();

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_concat() AS
+>//BEGIN
	PRINT CONCAT('a', 'b', NULL, 'c');
	PRINT 'A'||'B';
	PRINT CONCAT(NULL,NULL,NULL);	
END//;

--- SQL operation complete.
>>CALL test_concat();

(EXPR)
------

abc   

--- 1 row(s) selected.

(EXPR)
------

AB    

--- 1 row(s) selected.

(EXPR)               
---------------------

                    ?

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_current_date() AS
+>//BEGIN
    PRINT CURRENT_DATE;
    PRINT CURRENT DATE;
END//;

--- SQL operation complete.
>>CALL test_current_date();

(EXPR)    
----------

2018-09-05

--- 1 row(s) selected.

(EXPR)    
----------

2018-09-05

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_current_timestamp() AS
+>//BEGIN
PRINT CURRENT_TIMESTAMP(0);
PRINT CURRENT TIMESTAMP (0);
END//;

--- SQL operation complete.
>>CALL test_current_timestamp();

(EXPR)             
-------------------

2018-09-05 05:33:16

--- 1 row(s) selected.

(EXPR)             
-------------------

2018-09-05 05:33:16

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_current_user() AS
+>//BEGIN
	PRINT CURRENT_USER;
	PRINT CURRENT USER;
    PRINT USER;
END//;

--- SQL operation complete.
>>CALL test_current_user();

(EXPR)  
--------

DB__ROOT

--- 1 row(s) selected.

(EXPR)  
--------

DB__ROOT

--- 1 row(s) selected.

(EXPR)  
--------

DB__ROOT

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_date() AS
+>//BEGIN
PRINT DATE('2015-03-12');
PRINT DATE('2015' || '-03-' || '12');
PRINT DATE(TIMESTAMP '2015-03-12 10:58:34.111');
END//;

--- SQL operation complete.
>>CALL test_date();

(EXPR)    
----------

2015-03-12

--- 1 row(s) selected.

(EXPR)    
----------

2015-03-12

--- 1 row(s) selected.

(EXPR)    
----------

2015-03-12

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_decode() AS
+>//BEGIN
        DECLARE var1 INT DEFAULT 3;
        PRINT DECODE (var1, 1, 'A', 2, 'B', 3, 'C');
        PRINT DECODE (var1, 1, 'A', 2, 'B', 'C');
        SET var1 = NULL;
        PRINT DECODE (var1, 1, 'A', 2, 'B', NULL, 'C');
END//;

--- SQL operation complete.
>>CALL test_decode();

(EXPR)  
--------

C       

--- 1 row(s) selected.

(EXPR)
------

C     

--- 1 row(s) selected.

(EXPR)
------

C     

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_dbms_output_put_line() AS
+>//BEGIN
        DBMS_OUTPUT.PUT_LINE('Hello, world!');
END//;

--- SQL operation complete.
>>CALL test_dbms_output_put_line();

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_from_unixtime() AS
+>//BEGIN
        PRINT from_unixtime(1447141681);
        PRINT from_unixtime(1447141681, 'yyyy-MM-dd');
END//;

--- SQL operation complete.
>>CALL test_from_unixtime();

(EXPR)             
-------------------

2015-11-10 07:48:01

--- 1 row(s) selected.

(EXPR)    
----------

2015-11-10

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_unix_timestamp() AS
+>//BEGIN
        PRINT UNIX_TIMESTAMP();
END//;

--- SQL operation complete.
>>CALL test_unix_timestamp();

(EXPR)              
--------------------

          1536125620

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_instr() AS
+>//BEGIN
        PRINT INSTR('abc', 'b');
        PRINT INSTR('abcabcabc', 'b', 3, 2);
        PRINT INSTR('abcabc', 'b', 3);   
        PRINT INSTR('abcabcabc', 'b', -3);
        PRINT INSTR('abcabcabc', 'b', -3, 2);
END//;

--- SQL operation complete.
>>CALL test_instr();

(EXPR)
------

     2

--- 1 row(s) selected.

(EXPR)
------

     8

--- 1 row(s) selected.

(EXPR)
------

     5

--- 1 row(s) selected.

(EXPR)
------

     5

--- 1 row(s) selected.

(EXPR)
------

     2

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_lower() AS
+>//BEGIN
        PRINT lower('ABC');
END//;

--- SQL operation complete.
>>CALL test_lower();

(EXPR)             
-------------------

abc                

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_len() AS
+>//BEGIN
        PRINT LEN('Abc ');
END//;

--- SQL operation complete.
>>CALL test_len();

(EXPR)
------

     3

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_length() AS
+>//BEGIN
        PRINT LENGTH('Abc ');
END//;

--- SQL operation complete.
>>CALL test_length();

(EXPR)
------

     4

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_now() AS
+>//BEGIN
	PRINT now();
END//;

--- SQL operation complete.
>>CALL test_now();

(EXPR)                 
-----------------------

2018-09-05 05:33:51.408

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_nvl() AS
+>//BEGIN
        PRINT NVL(NULL, 1);
        PRINT NVL(1);
        PRINT NVL(NULL, NULL, 1);
        PRINT NVL(NULL, NULL, NULL);
END//;

--- SQL operation complete.
>>CALL test_nvl();

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)               
---------------------

                    ?

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_nvl2() AS
+>//BEGIN
        PRINT NVL2(NULL, 1, 2);
	      PRINT NVL2(0, 1, 2);
	      PRINT NVL2('', 1, 2);
        
END//;

--- SQL operation complete.
>>CALL test_nvl2();

(EXPR)
------

     2

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

(EXPR)
------

     1

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_replace_2() AS
+>//BEGIN
        PRINT replace('2016-03-03', '-', '');
END//;

--- SQL operation complete.
>>CALL test_replace_2();

(EXPR)             
-------------------

20160303           

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_substr() AS
+>//BEGIN
        PRINT SUBSTR('Remark', 3);
        PRINT SUBSTR('Remark', 3, 3);
        PRINT SUBSTRING('Remark', 3);
        PRINT SUBSTRING('Remark', 3, 3);
END//;

--- SQL operation complete.
>>CALL test_substr();

(EXPR)             
-------------------

mark               

--- 1 row(s) selected.

(EXPR)
------

mar   

--- 1 row(s) selected.

(EXPR)
------

mark  

--- 1 row(s) selected.

(EXPR)
------

mar   

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_sysdate() AS
+>//BEGIN
        PRINT TO_CHAR(sysdate);
END//;

--- SQL operation complete.
>>CALL test_sysdate();

(EXPR)                 
-----------------------

2018-09-05 05:34:17.679

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_timestamp_iso() as
+>//BEGIN
        PRINT TIMESTAMP_ISO('2018-09-03');
        PRINT TIMESTAMP_ISO(DATE '2018-09-03');
END//;

--- SQL operation complete.
>>CALL test_timestamp_iso();

(EXPR)             
-------------------

2018-09-03 00:00:00

--- 1 row(s) selected.

(EXPR)             
-------------------

2018-09-03 00:00:00

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_to_char() AS
+>//BEGIN
        PRINT TO_CHAR(CURRENT_DATE);
END//;

--- SQL operation complete.
>>CALL test_to_char();

(EXPR)                 
-----------------------

2018-09-05             

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_to_timestamp() AS
+>//BEGIN
		PRINT TO_CHAR(TO_TIMESTAMP('2015-04-02', 'YYYY-MM-DD'));
		PRINT TO_CHAR(TO_TIMESTAMP('04/02/2015', 'mm/dd/yyyy'));
		PRINT TO_CHAR(TO_TIMESTAMP('2015-04-02 13:51:31', 'YYYY-MM-DD HH24:MI:SS'));
END//;

--- SQL operation complete.
>>CALL test_to_timestamp();

(EXPR)                 
-----------------------

2015-04-02 00:00:00    

--- 1 row(s) selected.

(EXPR)             
-------------------

2015-04-02 00:00:00

--- 1 row(s) selected.

(EXPR)             
-------------------

2015-04-02 13:51:31

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_trim() AS
+>//BEGIN
	    PRINT '#' || TRIM(' Hello ') || '#';
END//;

--- SQL operation complete.
>>CALL test_trim();

(EXPR)                 
-----------------------

#Hello#                

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_upper() AS
+>//BEGIN
        PRINT UPPER('abc');
END//;

--- SQL operation complete.
>>CALL test_upper();

(EXPR)                 
-----------------------

ABC                    

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_right() AS 
+>//BEGIN
  DECLARE s STRING;
  SELECT RIGHT('robert_john_smith', 5) INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_right();

S    
-----

smith

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_cast2() AS
+>//BEGIN
  DECLARE n INT;
  SELECT CAST('12' AS INT) INTO n from dual;
  PRINT n;
END//;

--- SQL operation complete.
>>CALL test_cast2();

N     
------

    12

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_substring() AS
+>//BEGIN
  DECLARE s STRING;
  SELECT SUBSTRING ('Robert John Smith' FROM 8 FOR 4) INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_substring();

S   
----

John

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_left() AS
+>//BEGIN
  DECLARE s STRING;
  SELECT left('robert john smith', 6) INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_left();

S     
------

robert

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_log() AS
+>//BEGIN
  DECLARE n double;
  SELECT LOG(2.0) INTO n from dual;
  PRINT n;
END//;

--- SQL operation complete.
>>CALL test_log();

N                    
---------------------

    .6931471805599453

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_replace() AS
+>//BEGIN
  UPDATE orders1 SET description = REPLACE(description, 'adescription', 'cdescription');
  select description from orders1;
END//;

--- SQL operation complete.
>>CALL test_replace();

DESCRIPTION
----------------------------------------------------------------------------------------------------

cdescription                                                                                        
bdescription                                                                                        

--- 2 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_day() AS
+>//BEGIN
  DECLARE d INT;
  SELECT day('2015-03-13') INTO d from dual;
  PRINT d;
END//;

--- SQL operation complete.
>>CALL test_day();

D     
------

    13

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_char2() AS
+>//BEGIN
  DECLARE c STRING;
  SELECT char(65) INTO c from dual;
  PRINT c;
END//;

--- SQL operation complete.
>>CALL test_char2();

C
-

A

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_second() AS
+>//BEGIN
  DECLARE s float;
  SELECT second('2008-04-21 08:15:00.000000') INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_second();

S    
-----

    0

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_row_number() AS
+>//BEGIN
	SELECT row_number() over(order by item) from orders1;
END//;

--- SQL operation complete.
>>CALL test_row_number();

(EXPR)              
--------------------

                   1
                   2

--- 2 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_user() AS
+>//BEGIN
  DECLARE s STRING;
  SELECT user INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_user();

S       
--------

DB__ROOT

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_trim2() AS
+>//BEGIN
  DECLARE s STRING;
  SELECT TRIM(' Robert ') INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_trim2();

S       
--------

Robert  

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_insert() AS
+>//BEGIN
  UPDATE orders1 SET description = INSERT (description, 6, 6, ' ption') WHERE description = 'bdescription';
  select description from orders1;
END//;

--- SQL operation complete.
>>CALL test_insert();

DESCRIPTION
----------------------------------------------------------------------------------------------------

cdescription                                                                                        
bdesc ptionn                                                                                        

--- 2 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_concat2() AS 
+>//BEGIN
  DECLARE s STRING;
  SELECT concat('a','b') INTO s from dual;
  PRINT s;
END//;

--- SQL operation complete.
>>CALL test_concat2();

S 
--

ab

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_lead() AS
+>//BEGIN
	SELECT item,description,lead(item,1,'ddescription') over ( order by item ) from orders1;
END//;

--- SQL operation complete.
>>CALL test_lead();

ITEM                                                                                                  DESCRIPTION                                                                                           (EXPR)
----------------------------------------------------------------------------------------------------  ----------------------------------------------------------------------------------------------------  ----------------------------------------------------------------------------------------------------

aitem                                                                                                 cdescription                                                                                          bitem                                                                                               
bitem                                                                                                 bdesc ptionn                                                                                          ddescription                                                                                        

--- 2 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_count() as //
DECLARE
   count1 int;
BEGIN
   SELECT COUNT(*) INTO count1 FROM emp;
   PRINT count1;
END//;

--- SQL operation complete.
>>CALL test_count();

COUNT1
------

     2

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_avg() as //
DECLARE
   avg1 emp.salary%type;
BEGIN
   SELECT AVG(salary) INTO avg1 FROM emp;
   PRINT avg1;
END//;

--- SQL operation complete.
>>CALL test_avg();

AVG1        
------------

        2800

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_sum() as //
DECLARE
   sum1 emp.salary%type;
BEGIN
   SELECT SUM(salary) INTO sum1 FROM emp;
   PRINT sum1;
END//;

--- SQL operation complete.
>>CALL test_sum();

SUM1        
------------

        5600

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_min() as //
DECLARE
   min1 emp.salary%type;
BEGIN
   SELECT MIN(salary) INTO min1 FROM emp;
   PRINT min1;
END//;

--- SQL operation complete.
>>CALL test_min();

MIN1        
------------

        2600

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_max() as //
DECLARE
   max1 emp.salary%type;
BEGIN
   SELECT MAX(salary) INTO max1 FROM emp;
   PRINT max1;
END//;

--- SQL operation complete.
>>CALL test_max();

MAX1        
------------

        3000

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_stddev() as //
DECLARE
   std1 DOUBLE;
   std2 DOUBLE;
   std3 DOUBLE;
BEGIN
   SELECT STDDEV(salary) INTO std1 FROM emp LIMIT 1;
   PRINT std1;
   SELECT STDDEV(DISTINCT salary) INTO std2 FROM emp LIMIT 1;
   PRINT std2;
   SELECT STDDEV(salary,1.2) INTO std3 FROM emp LIMIT 1;
   PRINT std3;
END//;

--- SQL operation complete.
>>CALL test_stddev();

STD1                 
---------------------

     282.842712474619

--- 1 row(s) selected.

STD2                 
---------------------

     282.842712474619

--- 1 row(s) selected.

STD3                 
---------------------

   261.86146828319085

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create or replace procedure test_esgyn_decode() as //
DECLARE
   c1 CHAR(10);
   c2 CHAR(10);
BEGIN
   SELECT JOB_ID INTO c2 FROM EMP LIMIT 1;
   SELECT DECODE(job_id,'AD_VP','VP','FI_MGR','MGR','PU_MAN','MAN','MK_REP','REP','OTHERS') INTO c1 FROM emp LIMIT 1;
   PRINT C1;
   PRINT C2;
END//;

--- SQL operation complete.
>>CALL test_esgyn_decode();

C1    
------

OTHERS

--- 1 row(s) selected.

C2      
--------

SH_CLERK

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE test_bool_hplsql() AS //
declare 
	b1 bool = true;
	b2 boolean = false;
BEGIN
  set b1 = false;
  set b2 = true;
  if b2 then
    PRINT 'ok';
  else
    PRINT 'failed';
  end if;
END//;

--- SQL operation complete.
>>CALL test_bool_hplsql();

(EXPR)                 
-----------------------

ok                     

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE test_file_type() as //
DECLARE
   f UTL_FILE.FILE_TYPE;
   f2 UTL_FILE.FILE_TYPE;
   n1 VARCHAR(100);
BEGIN
   PRINT 'file_type test';
   f := UTL_FILE.FOPEN('/tmp','new_hello.txt','w');
   UTL_FILE.PUT(f,'1 hello world');
   UTL_FILE.PUT_LINE(f,'2 hello world');
   UTL_FILE.FCLOSE(f);
   f2 := UTL_FILE.FOPEN('/tmp','new_hello.txt','r');
   UTL_FILE.GET_LINE(f2,n1,200);
   PRINT 'n1' + n1;
END//;

--- SQL operation complete.
>>CALL test_file_type();

(EXPR)                 
-----------------------

file_type test         

--- 1 row(s) selected.

(EXPR)                      
----------------------------

n11 hello world2 hello world

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE mytest_exit() AS //
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    PRINT 'mytest_exit Error raised, outer handler';

  BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      PRINT 'mytest_exit Error raised, resignal';
      RESIGNAL;
    END;
    PRINT 'mytest_exit Before executing SQL';
    SELECT * FROM TEST_PLSQL.TEST_1;
    PRINT 'mytest_exit After executing SQL not be printed';
  END;
  PRINT 'mytest_exit Continue outer block after exiting inner';
END//;

--- SQL operation complete.
>>CALL mytest_exit();

(EXPR)                          
--------------------------------

mytest_exit Before executing SQL

--- 1 row(s) selected.

(EXPR)                            
----------------------------------

mytest_exit Error raised, resignal

--- 1 row(s) selected.

(EXPR)                                 
---------------------------------------

mytest_exit Error raised, outer handler

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE mytest_continue() AS //
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    PRINT 'mytest_continue Error raised, outer handler';

  BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      PRINT 'mytest_continue Error raised, resignal';
      RESIGNAL;
    END;
    PRINT 'mytest_continue Before executing SQL';
    SELECT * FROM TEST_PLSQL.TEST_1;
    PRINT 'mytest_continue After executing SQL not be printed';
  END;
  PRINT 'mytest_continue Continue outer block after exiting inner';
END//;

--- SQL operation complete.
>>CALL mytest_continue();

(EXPR)                              
------------------------------------

mytest_continue Before executing SQL

--- 1 row(s) selected.

(EXPR)                                
--------------------------------------

mytest_continue Error raised, resignal

--- 1 row(s) selected.

(EXPR)                                     
-------------------------------------------

mytest_continue Error raised, outer handler

--- 1 row(s) selected.

(EXPR)                                                  
--------------------------------------------------------

mytest_continue Continue outer block after exiting inner

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE mytest2() AS //
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    	GET DIAGNOSTICS EXCEPTION 1 text = MESSAGE_TEXT;
        GET DIAGNOSTICS var_name = ROW_COUNT;
  	PRINT 'mytest2 SQLSTATE: ' || SQLSTATE;
        PRINT 'ROW_COUNT:' || var_name;
    PRINT 'mytest2 Text: ' || text;
  END; 
 
  BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
      RESIGNAL SQLSTATE '02031' SET MESSAGE_TEXT = 'Some error';
    SELECT * FROM abc;    
  END;
END//;

--- SQL operation complete.
>>CALL mytest2();

(EXPR)                 
-----------------------

mytest2 SQLSTATE: 02031

--- 1 row(s) selected.

(EXPR)     
-----------

ROW_COUNT:0

--- 1 row(s) selected.

(EXPR)                  
------------------------

mytest2 Text: Some error

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE mytest3() AS //
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
            insert into test_results values('mytest3 Error raised');
            RESIGNAL;
    END;
    insert into test_results values ('mytest3 Before executing SQL');
    SELECT * FROM abc;
    insert into test_results values('mytest3 After executing SQL - will not be printed in case of error');
END//;

--- SQL operation complete.
>>BEGIN WORK;

--- SQL operation complete.
>>CALL mytest3();

*** ERROR[11220] A Java method completed with an uncaught java.sql.SQLException with invalid SQLSTATE. The uncaught exception had a SQLCODE of -4082 and SQLSTATE of 42000. Details: java.sql.SQLException: *** ERROR[4082] Object TRAFODION.SCH.ABC does not exist or is inaccessible.

*** ERROR[11224] The Java virtual machine raised an exception. Details: java.sql.SQLException: *** ERROR[8822] The statement was not prepared.

--- SQL operation failed with errors.
>>select * from test_results;

RESULTS
--------------------------------------------------------------------------------

mytest3 Before executing SQL                                                    
mytest3 Error raised                                                            

--- 2 row(s) selected.
>>COMMIT;

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_set_session() as
+>//BEGIN
	DECLARE s string;
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
            PRINT 'SEABASE.TB_TEST TABLE NOT EXIST';
	SET SCHEMA = 'seabase';
	select a into s from tb_test;
	print s;
	SET CURRENT_SCHEMA = 'sch';
	select a into s from tb_test;
	SET SCHEMA = 'sea' || 'base';
	select a into s from tb_test;
	print s; 
END//;

--- SQL operation complete.
>>CALL test_set_session();

S   
----

test

--- 1 row(s) selected.

(EXPR)                         
-------------------------------

SEABASE.TB_TEST TABLE NOT EXIST

--- 1 row(s) selected.

S   
----

test

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_values() AS
+>//BEGIN
	DECLARE code varchar2(1);
	DECLARE count1 int;
	DECLARE limit1 int;
	VALUES 'A' INTO code;
	VALUES (0, 100) INTO (count1, limit1); 
	PRINT code;
  PRINT count1;
  PRINT limit1;
END//;

--- SQL operation complete.
>>CALL test_values();

CODE
----

A   

--- 1 row(s) selected.

COUNT1
------

     0

--- 1 row(s) selected.

LIMIT1
------

   100

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_declare_condition_exit() AS //
BEGIN
        DECLARE cnt INT DEFAULT 0;
        DECLARE wrong_cnt_condition CONDITION;

        DECLARE EXIT HANDLER FOR wrong_cnt_condition
                PRINT 'declare_cindition_exit Wrong number of rows';

        SELECT COUNT(*) INTO cnt FROM orders1;

        IF cnt <> 1 THEN
                SIGNAL wrong_cnt_condition;
        END IF;
END//;

--- SQL operation complete.
>>CALL test_declare_condition_exit();

(EXPR)                                     
-------------------------------------------

declare_cindition_exit Wrong number of rows

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_declare_condition_continue() AS //
BEGIN
        DECLARE cnt INT DEFAULT 0;
        DECLARE wrong_cnt_condition CONDITION;

        DECLARE CONTINUE HANDLER FOR wrong_cnt_condition
                PRINT 'declare_cindition_continue Wrong number of rows';

        SELECT COUNT(*) INTO cnt FROM orders1;

        IF cnt <> 1 THEN
                SIGNAL wrong_cnt_condition;
        END IF;
END//;

--- SQL operation complete.
>>CALL test_declare_condition_continue();

(EXPR)                                         
-----------------------------------------------

declare_cindition_continue Wrong number of rows

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_declare_cursor() AS //
BEGIN
        DECLARE id STRING;
        DECLARE cur CURSOR FOR SELECT item FROM orders1;
        OPEN cur;
        FETCH cur INTO id;
        WHILE SQLCODE=0 THEN
          PRINT id;
          FETCH cur INTO id;
        END WHILE;
        CLOSE cur;
END//;

--- SQL operation complete.
>>CALL test_declare_cursor();

ID   
-----

aitem

--- 1 row(s) selected.

ID   
-----

bitem

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_declare_cursor2() AS //
BEGIN
        DECLARE tabname VARCHAR DEFAULT 'orders1';
        DECLARE id STRING;
        DECLARE cur CURSOR FOR 'SELECT item FROM ' || tabname;
        OPEN cur;
        FETCH cur INTO id;
        WHILE SQLCODE=0 THEN
          PRINT id;
          FETCH cur INTO id;
        END WHILE;
        CLOSE cur;
END//;

--- SQL operation complete.
>>CALL test_declare_cursor2();

ID   
-----

aitem

--- 1 row(s) selected.

ID   
-----

bitem

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>-- CREATE PROCEDURE test_declare_handler_exit() AS //
>>--   DECLARE name VARCHAR(100);
>>--   DECLARE no_rows INT DEFAULT 0; 
>>--    
>>--   DECLARE EXIT HANDLER FOR NOT FOUND
>>--     SET no_rows = 1;    
>>--    
>>--   OPEN cur FOR 'SELECT item FROM orders1';
>>--    
>>--   FETCH cur INTO name;
>>--   WHILE no_rows = 0 THEN  
>>--     INSERT INTO tb_declare_handler VALUES(name);
>>--     FETCH cur INTO name;
>>--   END WHILE;
>>--   CLOSE cur;
>>-- end//;
>>
>>CREATE PROCEDURE test_declare_handler_continue() AS //
BEGIN
  DECLARE name VARCHAR(100);
  DECLARE no_rows INT DEFAULT 0; 
  OPEN cur FOR 'SELECT item FROM orders1';
   
  FETCH cur INTO name;
  WHILE SQLCODE = 0 THEN  
    PRINT name;
    FETCH cur INTO name;
  END WHILE;
  CLOSE cur;
end//;

--- SQL operation complete.
>>CALL test_declare_handler_continue();

NAME 
-----

aitem

--- 1 row(s) selected.

NAME 
-----

bitem

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_case() AS
+>//BEGIN
  DECLARE state varchar2(10) := 'AZ';
  DECLARE s_case varchar2(10);
  SELECT CASE state
   WHEN 'AZ' THEN 'Arizona'
   WHEN 'CA' THEN 'California'
   ELSE 'N/A'
  END INTO s_case;
  PRINT s_case;
END//;

--- SQL operation complete.
>>CALL test_case();

S_CASE 
-------

Arizona

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_operators() AS 
+>//BEGIN
  IF 3=3 THEN
    PRINT '3=3 TRUE';
  ELSE
    PRINT '3=3 FALSE';
  END IF;
  IF 3=1 THEN
    PRINT '3=1 TRUE';
  ELSE
    PRINT '3=1 FALSE';
  END IF;
  IF 'CA'=NULL THEN
    PRINT 'CA=NULL TRUE';
  ELSE
    PRINT 'CA=NULL FALSE';
  END IF;
  IF 3==3 THEN
    PRINT '3==3 TRUE';
  ELSE
    PRINT '3==3 FALSE';
  END IF;
  IF 3<>3 THEN
    PRINT '3<>3 TRUE';
  ELSE
    PRINT '3<>3 FALSE';
  END IF;
  IF 3!=3 THEN
    PRINT '3!=3 TRUE';
  ELSE
    PRINT '3!=3 FALSE';
  END IF;
  IF 3>1 THEN
    PRINT '3>1 TRUE';
  ELSE
    PRINT '3>1 FALSE';
  END IF;
  IF 3<1 THEN
    PRINT '3<1 TRUE';
  ELSE
    PRINT '3<1 FALSE';
  END IF;
  IF 3>=1 THEN
    PRINT '3>=1 TRUE';
  ELSE
    PRINT '3>=1 FALSE';
  END IF;  
  IF 3<=1 THEN
    PRINT '3<=1 TRUE';
  ELSE
    PRINT '3<=1 FALSE';
  END IF;
END//;

--- SQL operation complete.
>>CALL test_operators();

(EXPR)                                         
-----------------------------------------------

3=3 TRUE                                       

--- 1 row(s) selected.

(EXPR)   
---------

3=1 FALSE

--- 1 row(s) selected.

(EXPR)       
-------------

CA=NULL FALSE

--- 1 row(s) selected.

(EXPR)   
---------

3==3 TRUE

--- 1 row(s) selected.

(EXPR)    
----------

3<>3 FALSE

--- 1 row(s) selected.

(EXPR)    
----------

3!=3 FALSE

--- 1 row(s) selected.

(EXPR)  
--------

3>1 TRUE

--- 1 row(s) selected.

(EXPR)   
---------

3<1 FALSE

--- 1 row(s) selected.

(EXPR)   
---------

3>=1 TRUE

--- 1 row(s) selected.

(EXPR)    
----------

3<=1 FALSE

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_hostcode() AS
+>//BEGIN
  declare s1 varchar(20);
  select s into s1 from tb_hostcode;
  PRINT ACTIVITY_COUNT; 
  select * from tb_hostcode;
  declare s_errorcode varchar(20) = errorcode;
  PRINT s_errorcode;
  HOST 'echo hello, world';
  IF HOSTCODE <> 0 THEN
    PRINT "HOSTCODE ERROR";
  END IF;
END//;

--- SQL operation complete.
>>CALL test_hostcode();

(EXPR)
------

     1

--- 1 row(s) selected.

S                     S2                  
--------------------  --------------------

ss                    sss                 

--- 1 row(s) selected.

S_ERRORCODE
-----------

0          

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE spOpenIssues1() DYNAMIC RESULT SETS 1 as//
BEGIN
  DECLARE cur CURSOR WITH RETURN FOR
    SELECT item, description FROM orders1;
  OPEN cur;
END//;

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE spOpenIssues11() as //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
      
  CALL trafodion.sch.spOpenIssues1;
  ALLOCATE c1 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues1;

  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
END//;

--- SQL operation complete.
>>CALL spOpenIssues11();

(EXPR)              
--------------------

aitem - cdescription

--- 1 row(s) selected.

(EXPR)              
--------------------

bitem - bdesc ptionn

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE OR REPLACE PROCEDURE spOpenIssues12() as //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE loc RESULT_SET_LOCATOR VARYING;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
      
  CALL trafodion.sch.spOpenIssues1;
  ASSOCIATE RESULT SET LOCATOR (loc) WITH PROCEDURE trafodion.sch.spOpenIssues1;
  ALLOCATE c1 CURSOR FOR RESULT SET loc;
   
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
END//;

--- SQL operation complete.
>>CALL spOpenIssues12();

(EXPR)              
--------------------

aitem - cdescription

--- 1 row(s) selected.

(EXPR)              
--------------------

bitem - bdesc ptionn

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>
>>CREATE or replace PROCEDURE spOpenIssues2() DYNAMIC RESULT SETS 2 AS //
BEGIN
    DECLARE cur CURSOR WITH RETURN FOR
      SELECT item, description FROM orders1;
    DECLARE cur2 CURSOR WITH RETURN FOR
      SELECT item, description FROM ORDERS2;
    OPEN cur;
    OPEN cur2;
END//;

--- SQL operation complete.
>>
>>CREATE or replace PROCEDURE spOpenIssues21() AS //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  CALL trafodion.sch.spOpenIssues2;
  ALLOCATE c1 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
  
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
   
  ALLOCATE c2 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues2;
  FETCH c2 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c2 INTO item, description;
  END WHILE;
  CLOSE c2;
END//;

--- SQL operation complete.
>>call spOpenIssues21();

(EXPR)              
--------------------

aitem - cdescription

--- 1 row(s) selected.

(EXPR)              
--------------------

bitem - bdesc ptionn

--- 1 row(s) selected.

(EXPR)                                         
-----------------------------------------------

2aitem - 2adescription                         

--- 1 row(s) selected.

(EXPR)                
----------------------

2bitem - 2bdescription

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE or replace PROCEDURE spOpenIssues22() AS //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE loc1 RESULT_SET_LOCATOR VARYING;
  DECLARE loc2 RESULT_SET_LOCATOR VARYING;
   
  CALL trafodion.sch.spOpenIssues2;
  ASSOCIATE RESULT SET LOCATOR (loc1, loc2) WITH PROCEDURE trafodion.sch.spOpenIssues2;
  
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;

  ALLOCATE c1 CURSOR FOR RESULT SET loc1;
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
   
  ALLOCATE c2 CURSOR FOR RESULT SET loc2;
  FETCH c2 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c2 INTO item, description;
  END WHILE;
  CLOSE c2;
END//;

--- SQL operation complete.
>>call spOpenIssues22();

(EXPR)              
--------------------

aitem - cdescription

--- 1 row(s) selected.

(EXPR)              
--------------------

bitem - bdesc ptionn

--- 1 row(s) selected.

(EXPR)                
----------------------

2aitem - 2adescription

--- 1 row(s) selected.

(EXPR)                
----------------------

2bitem - 2bdescription

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>CREATE PROCEDURE test_include() as//
begin
INCLUDE $$QUOTE$$$$scriptsdir$$/udr/set_message.sql$$QUOTE$$;
 
DECLARE str STRING;
CALL set_message('world', str);
PRINT str;
end//;

--- SQL operation complete.
>>CALL test_include();

STR          
-------------

Hello, world!

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>create procedure test_interval() as//
begin
print DATE '2015-03-12' + 1 DAY;
print TIMESTAMP '2015-03-12' + 1 DAY;
print DATE '2015-03-12' + NVL(NULL, 3) DAYS;
print TIMESTAMP '2015-03-12' + NVL(NULL, 3) DAYS;
print TIMESTAMP '2015-03-12 10:10:10.000' - 1 MICROSECOND; 
print TIMESTAMP '2015-03-12' - 1 DAY - 1 MICROSECOND;
print date '2016-01-27' - interval '3' day;
end//;

--- SQL operation complete.
>>call test_interval();

(EXPR)    
----------

2015-03-13

--- 1 row(s) selected.

(EXPR)             
-------------------

2015-03-13 00:00:00

--- 1 row(s) selected.

(EXPR)    
----------

2015-03-15

--- 1 row(s) selected.

(EXPR)             
-------------------

2015-03-15 00:00:00

--- 1 row(s) selected.

(EXPR)                 
-----------------------

2015-03-12 10:10:09.999

--- 1 row(s) selected.

(EXPR)             
-------------------

2015-03-10 23:59:59

--- 1 row(s) selected.

(EXPR)    
----------

2016-01-24

--- 1 row(s) selected.

--- SQL operation complete.
>>
>>log;
