-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@

set pattern $$QUOTE$$ '''';

obey TEST333(clean);
log LOG333 clear;
obey TEST333(setup);
log;
obey TEST333(clean);
exit;

?section setup

CREATE TABLE orders1 (item VARCHAR(100),description VARCHAR(100));
INSERT INTO orders1 VALUES('aitem','adescription');
INSERT INTO orders1 VALUES('bitem','bdescription');

CREATE TABLE orders2 (item VARCHAR(100),description VARCHAR(100));
INSERT INTO orders2 VALUES('2aitem','2adescription');
INSERT INTO orders2 VALUES('2bitem','2bdescription');

create table emp(
  employee_id    decimal(6),
  first_name     VARCHAR(20),
  last_name      VARCHAR(25),
  email          VARCHAR(25),
  phone_decimal   VARCHAR(20),
  hire_date      DATE,
  job_id         VARCHAR(10),
  salary         decimal(8,2),
  commission_pct decimal(2,2),
  manager_id     decimal(6),
  department_id  decimal(4)
);
insert into emp values (198,'Donald','OConnell','DOCONNEL','650.507.9833',date '2007-06-21','SH_CLERK',2600,null,'124','50');
insert into emp values (199,'Douglas','Grant','DGRANT','650.507.9844',date '2008-01-13','SH_CLERK',3000,null,'124','50');

CREATE TABLE seabase.tb_test(a varchar2(10));
INSERT INTO seabase.tb_test values('test');

CREATE TABLE tb_hostcode(s VARCHAR2(20), s2 VARCHAR2(20));
insert into tb_hostcode values('ss','sss');

CREATE TABLE test_results(RESULTS VARCHAR(80));

CREATE TABLE table_t1(t int);
CREATE TABLE table_t2(t int);

CREATE PROCEDURE test_defining_variables() AS
//BEGIN
  DECLARE code CHAR(10) = 'code';
  DECLARE status, status2 INT DEFAULT 1;
  DECLARE limit1 INT DEFAULT 100;
  DECLARE num INT := 1;
  DECLARE num2 INT = 2;
  PRINT code;
  PRINT status;
  PRINT status2;
  PRINT limit1;
  PRINT num;
  PRINT num2;
END//;
CALL test_defining_variables();

CREATE or replace PROCEDURE test_defining_variables2() AS //
DECLARE
  SUBstr varchar2(20) := 'REMark';
  SUBSTr1 varchar2(20) := 'REMArk';
  "SUBSTR2" varchar2(20) := 'REMARK';
  "SUBstr2" varchar2(20) := 'Remark';
  "SUBstr" varchar2(20) := 'remark';
BEGIN
  print SUBstr1;
  print "SUBSTR2";
  print "SUBstr2"; 
  print SUBSTR1;
  print "SUBSTR";
  print "SUBstr";
END//;
CALL test_defining_variables2();

CREATE PROCEDURE test_flow_control() AS
//BEGIN
        DECLARE Flow_Control_count INT DEFAULT 3;
        WHILE 1=1 BEGIN
          SET Flow_Control_count = Flow_Control_count - 1;
          PRINT Flow_Control_count;
          IF Flow_Control_count = 0 
            BREAK;
          END;
        END;
END//;
CALL test_flow_control();

CREATE PROCEDURE test_exit_when2() AS
//BEGIN
        <<lbl>>
        WHILE 1=1 LOOP
          <<lbl1>>
          WHILE 1=1 LOOP
          	PRINT 'If not print error then correct';
		        EXIT lbl;
          END LOOP;
          PRINT 'error';
        END LOOP;
END//;
CALL test_exit_when2();


CREATE PROCEDURE test_exit_when() AS
//BEGIN
        DECLARE count2 INT DEFAULT 3;
        WHILE count2 > 0 LOOP
          count2 := count2 - 1;
          PRINT count2; 
          EXIT WHEN count2 = 0;
        END LOOP;
END//;
CALL test_exit_when();

CREATE PROCEDURE test_for_cursorloop() AS
//BEGIN
        FOR ordersrows IN (
            SELECT item, description
            FROM orders1
            WHERE item LIKE '%a%')
        LOOP
          PRINT ordersrows.item;
          PRINT ordersrows.description;
        END LOOP;
END//;
CALL test_for_cursorloop();

CREATE PROCEDURE test_for() AS
//BEGIN
        FOR i IN 1..10 LOOP
            PRINT i;
        END LOOP;

        FOR i IN REVERSE 1..10 LOOP
            PRINT i;
        END LOOP;

        FOR i IN 1..10 BY 2 LOOP
            PRINT I;
        END LOOP;
END//;
CALL test_for();

CREATE PROCEDURE test_ifelse() AS
//BEGIN
        DECLARE ifelse_code INT;
        DECLARE state VARCHAR(10) = 'CA';
        IF state = 'CA' THEN
          ifelse_code := 1;
        ELSIF state = 'NY' THEN
          ifelse_code := 2;
        ELSIF state = 'MA' THEN
          ifelse_code := 3;
        ELSE
          ifelse_code := 5;
        END IF;
        PRINT ifelse_code;
END//;
CALL test_ifelse();

CREATE PROCEDURE test_leave() AS
//BEGIN
        DECLARE LEAVE_count INT = 3;
        lbl:
        WHILE LEAVE_count > 0 DO
          SET LEAVE_count = LEAVE_count - 1;
          PRINT LEAVE_count;
          IF LEAVE_count = 0 THEN
            LEAVE lbl;
          END IF;
        END WHILE;
END//;
CALL test_leave();

CREATE PROCEDURE test_while() AS
//BEGIN
        DECLARE WHILE_count INT = 3;
        WHILE WHILE_count > 0 BEGIN
          WHILE_count := WHILE_count - 1;
          PRINT WHILE_count;
        END;
END//;
CALL test_while();

CREATE PROCEDURE test_close() AS
//BEGIN
        DECLARE close_id VARCHAR(100);
        DECLARE close_cur CURSOR FOR 'SELECT item FROM orders1';
        OPEN close_cur;
        FETCH close_cur INTO close_id;
        PRINT close_id;
        CLOSE close_cur;
END//;
CALL test_close();

CREATE PROCEDURE test_cursor_attributes() AS
//BEGIN
        DECLARE CURSOR cursor_attributes_c1 IS SELECT item FROM orders1 LIMIT 1;
        DECLARE cursor_attributes_v1 VARCHAR(100);
	      DECLARE CONTINUE HANDLER FOR NOT FOUND
                PRINT 'Wrong number of rows';
        BEGIN
          OPEN cursor_attributes_c1;
          IF cursor_attributes_c1%ISOPEN THEN
            PRINT 'Cursor open';
          END IF; 
          FETCH cursor_attributes_c1 INTO cursor_attributes_v1;
          IF cursor_attributes_c1%FOUND THEN
            PRINT 'Row found';
          END IF;  
          FETCH cursor_attributes_c1 INTO cursor_attributes_v1;
          IF cursor_attributes_c1%NOTFOUND THEN
            PRINT 'Row not found';
          END IF;  
          CLOSE cursor_attributes_c1; 
        END;
END//;
CALL test_cursor_attributes();

CREATE PROCEDURE test_fetch() AS
//BEGIN
        DECLARE fetch_tabname VARCHAR DEFAULT 'orders1';
        DECLARE fetch_item VARCHAR(100);
        DECLARE fetch_cur CURSOR FOR 'SELECT item FROM ' || fetch_tabname;
        OPEN fetch_cur;
        FETCH fetch_cur INTO fetch_item;
        WHILE SQLCODE=0 THEN
          PRINT fetch_item;
          FETCH fetch_cur INTO fetch_item;
        END WHILE;
        CLOSE fetch_cur;
END//;
CALL test_fetch();

CREATE PROCEDURE test_dynamicSQL() AS
//BEGIN
        DECLARE DynamicSQL_cnt INT;
        EXECUTE 'SELECT COUNT(*) FROM orders1' INTO DynamicSQL_cnt;
        PRINT DynamicSQL_cnt;
        DECLARE tabname VARCHAR(100) DEFAULT 'tab1';
        EXECUTE IMMEDIATE 'CREATE TABLE ' || tabname || ' (c1 INT)';
		    INSERT INTO tab1 VALUES(1);
	      EXEC 'SELECT COUNT(*) FROM orders1' INTO DynamicSQL_cnt;
	      PRINT DynamicSQL_cnt;
END//;
CALL test_dynamicSQL();
SELECT * FROM tab1;

CREATE PROCEDURE test_exception_block() AS
//BEGIN
        DECLARE EXCEPTION_BLOCK_v VARCHAR(200);
        BEGIN
          OPEN EXCEPTION_BLOCK_cur FOR 'SELECT c1 FROM t1';
          FETCH EXCEPTION_BLOCK_cur INTO EXCEPTION_BLOCK_v;
          CLOSE EXCEPTION_BLOCK_cur;
        EXCEPTION WHEN OTHERS THEN
          PRINT 'Error';
        END;
END//;
CALL test_exception_block();

CREATE PROCEDURE test_rowtype_type () AS
//BEGIN
        DECLARE ROWTYPE_TYPE_v orders1%ROWTYPE;

        SELECT * INTO ROWTYPE_TYPE_v FROM orders1 LIMIT 1;
        PRINT ROWTYPE_TYPE_v.item;
        PRINT ROWTYPE_TYPE_v.description;

        DECLARE ROWTYPE_TYPE_v1 orders1%ROWTYPE;
        DECLARE CURSOR ROWTYPE_TYPE_c1 IS SELECT * FROM orders1;
        OPEN ROWTYPE_TYPE_c1;
        FETCH ROWTYPE_TYPE_c1 INTO ROWTYPE_TYPE_v1;
        PRINT ROWTYPE_TYPE_v1.item;
        PRINT ROWTYPE_TYPE_v1.description;
        CLOSE ROWTYPE_TYPE_c1;

        DECLARE ROWTYPE_TYPE_v2 orders1%ROWTYPE;
        FOR ROWTYPE_TYPE_v2 IN (SELECT * FROM orders1)
        LOOP
          PRINT ROWTYPE_TYPE_v2.item;
          PRINT ROWTYPE_TYPE_v2.description;
        END LOOP;

        DECLARE ROWTYPE_TYPE_v3 orders1%ROWTYPE;
        EXECUTE IMMEDIATE 'SELECT * FROM orders1 LIMIT 1' INTO ROWTYPE_TYPE_v3;
        PRINT ROWTYPE_TYPE_v3.item;
        PRINT ROWTYPE_TYPE_v3.description;

        DECLARE ROWTYPE_TYPE_i orders1.item%TYPE;
        SELECT item INTO ROWTYPE_TYPE_i FROM orders1 LIMIT 1;
        PRINT ROWTYPE_TYPE_i;
END//;
CALL test_rowtype_type();

create or replace procedure test_temp() as
//begin
SET hplsql.temp.tables = managed;
DECLARE TEMPORARY TABLE temp(  
   c1 INT,
   c2 varchar(10));
INSERT INTO temp SELECT 1, 'A' FROM dual;
SELECT * FROM temp;
end//;
call test_temp();

create or replace procedure test_temp() as
//begin
SET hplsql.temp.tables = managed; 
CREATE LOCAL TEMPORARY TABLE temp1
(
   c1 INT,
   c2 varchar(10)
);
 
INSERT INTO temp1 SELECT 1, 'A' FROM dual;
 
SELECT * FROM temp1;
end//;
call test_temp();

CREATE PROCEDURE test_schema() AS
//BEGIN
CREATE SCHEMA T_SCHEMA;
END//;
CALL test_schema();

CREATE PROCEDURE TEST_DESC() AS
//BEGIN
DESC orders1;
DESCRIBE orders2;
END//;
CALL test_desc();

create procedure test_null() AS
//BEGIN
  	null;
end//;
CALL test_null();

CREATE PROCEDURE test_drop_table_1() AS//
BEGIN
DROP TABLE IF EXISTS table_t1;
SELECT * FROM table_t1;
END//;
CALL test_drop_table_1();

CREATE PROCEDURE test_drop_table_2() AS//
BEGIN
DROP TABLE table_t2;
SELECT * FROM table_t2;
END//;
CALL test_drop_table_2();

CREATE PROCEDURE test_use() AS
//BEGIN
        use seabase;
        create table t_test_use(a int);
        insert into t_test_use values(1);
        select * from trafodion.seabase.t_test_use;
END//;
CALL test_use();

CREATE PROCEDURE test_cast () AS
//BEGIN
		PRINT CAST('Abc' AS CHAR(1));
		PRINT CAST(TIMESTAMP '2015-03-12 10:58:34.111' AS CHAR(50));
		PRINT CAST('123' AS INT);
		PRINT CAST('1.23' AS FLOAT);
		PRINT CAST('1.23' AS DOUBLE);
		PRINT CAST('1.23' AS DECIMAL(10,4));
END//;
CALL test_cast();

CREATE PROCEDURE test_char () AS
//BEGIN
		PRINT CHAR(66);
END//;
CALL test_char();

CREATE PROCEDURE test_coalesce () AS
//BEGIN
        PRINT COALESCE(1, 2, 3);
        PRINT COALESCE(NULL, 1, 2, 3);
        PRINT COALESCE(NULL, NULL, 1, 2, 3);
END//;
CALL test_coalesce();

CREATE PROCEDURE test_concat() AS
//BEGIN
	PRINT CONCAT('a', 'b', NULL, 'c');
	PRINT 'A'||'B';
	PRINT CONCAT(NULL,NULL,NULL);	
END//;
CALL test_concat();

CREATE PROCEDURE test_current_date() AS
//BEGIN
    PRINT CURRENT_DATE;
    PRINT CURRENT DATE;
END//;
CALL test_current_date();

CREATE PROCEDURE test_current_timestamp() AS
//BEGIN
PRINT CURRENT_TIMESTAMP(0);
PRINT CURRENT TIMESTAMP (0);
END//;
CALL test_current_timestamp();

CREATE PROCEDURE test_current_user() AS
//BEGIN
	PRINT CURRENT_USER;
	PRINT CURRENT USER;
    PRINT USER;
END//;
CALL test_current_user();

CREATE PROCEDURE test_date() AS
//BEGIN
PRINT DATE('2015-03-12');
PRINT DATE('2015' || '-03-' || '12');
PRINT DATE(TIMESTAMP '2015-03-12 10:58:34.111');
END//;
CALL test_date();

CREATE PROCEDURE test_decode() AS
//BEGIN
        DECLARE var1 INT DEFAULT 3;
        PRINT DECODE (var1, 1, 'A', 2, 'B', 3, 'C');
        PRINT DECODE (var1, 1, 'A', 2, 'B', 'C');
        SET var1 = NULL;
        PRINT DECODE (var1, 1, 'A', 2, 'B', NULL, 'C');
END//;
CALL test_decode();

CREATE PROCEDURE test_dbms_output_put_line() AS
//BEGIN
        DBMS_OUTPUT.PUT_LINE('Hello, world!');
END//;
CALL test_dbms_output_put_line();

CREATE PROCEDURE test_from_unixtime() AS
//BEGIN
        PRINT from_unixtime(1447141681);
        PRINT from_unixtime(1447141681, 'yyyy-MM-dd');
END//;
CALL test_from_unixtime();

CREATE PROCEDURE test_unix_timestamp() AS
//BEGIN
        PRINT UNIX_TIMESTAMP();
END//;
CALL test_unix_timestamp();

CREATE PROCEDURE test_instr() AS
//BEGIN
        PRINT INSTR('abc', 'b');
        PRINT INSTR('abcabcabc', 'b', 3, 2);
        PRINT INSTR('abcabc', 'b', 3);   
        PRINT INSTR('abcabcabc', 'b', -3);
        PRINT INSTR('abcabcabc', 'b', -3, 2);
END//;
CALL test_instr();

CREATE PROCEDURE test_lower() AS
//BEGIN
        PRINT lower('ABC');
END//;
CALL test_lower();

CREATE PROCEDURE test_len() AS
//BEGIN
        PRINT LEN('Abc ');
END//;
CALL test_len();

CREATE PROCEDURE test_length() AS
//BEGIN
        PRINT LENGTH('Abc ');
END//;
CALL test_length();

CREATE PROCEDURE test_now() AS
//BEGIN
	PRINT now();
END//;
CALL test_now();

CREATE PROCEDURE test_nvl() AS
//BEGIN
        PRINT NVL(NULL, 1);
        PRINT NVL(1);
        PRINT NVL(NULL, NULL, 1);
        PRINT NVL(NULL, NULL, NULL);
END//;
CALL test_nvl();

CREATE PROCEDURE test_nvl2() AS
//BEGIN
        PRINT NVL2(NULL, 1, 2);
	      PRINT NVL2(0, 1, 2);
	      PRINT NVL2('', 1, 2);
        
END//;
CALL test_nvl2();

CREATE PROCEDURE test_replace_2() AS
//BEGIN
        PRINT replace('2016-03-03', '-', '');
END//;
CALL test_replace_2();

CREATE PROCEDURE test_substr() AS
//BEGIN
        PRINT SUBSTR('Remark', 3);
        PRINT SUBSTR('Remark', 3, 3);
        PRINT SUBSTRING('Remark', 3);
        PRINT SUBSTRING('Remark', 3, 3);
END//;
CALL test_substr();

CREATE PROCEDURE test_sysdate() AS
//BEGIN
        PRINT TO_CHAR(sysdate);
END//;
CALL test_sysdate();

CREATE PROCEDURE test_timestamp_iso() as
//BEGIN
        PRINT TIMESTAMP_ISO('2018-09-03');
        PRINT TIMESTAMP_ISO(DATE '2018-09-03');
END//;
CALL test_timestamp_iso();

CREATE PROCEDURE test_to_char() AS
//BEGIN
        PRINT TO_CHAR(CURRENT_DATE);
END//;
CALL test_to_char();

CREATE PROCEDURE test_to_timestamp() AS
//BEGIN
		PRINT TO_CHAR(TO_TIMESTAMP('2015-04-02', 'YYYY-MM-DD'));
		PRINT TO_CHAR(TO_TIMESTAMP('04/02/2015', 'mm/dd/yyyy'));
		PRINT TO_CHAR(TO_TIMESTAMP('2015-04-02 13:51:31', 'YYYY-MM-DD HH24:MI:SS'));
END//;
CALL test_to_timestamp();

CREATE PROCEDURE test_trim() AS
//BEGIN
	    PRINT '#' || TRIM(' Hello ') || '#';
END//;
CALL test_trim();

CREATE PROCEDURE test_upper() AS
//BEGIN
        PRINT UPPER('abc');
END//;
CALL test_upper();

CREATE PROCEDURE test_right() AS 
//BEGIN
  DECLARE s STRING;
  SELECT RIGHT('robert_john_smith', 5) INTO s from dual;
  PRINT s;
END//;
CALL test_right();

CREATE PROCEDURE test_cast2() AS
//BEGIN
  DECLARE n INT;
  SELECT CAST('12' AS INT) INTO n from dual;
  PRINT n;
END//;
CALL test_cast2();

CREATE PROCEDURE test_substring() AS
//BEGIN
  DECLARE s STRING;
  SELECT SUBSTRING ('Robert John Smith' FROM 8 FOR 4) INTO s from dual;
  PRINT s;
END//;
CALL test_substring();

CREATE PROCEDURE test_left() AS
//BEGIN
  DECLARE s STRING;
  SELECT left('robert john smith', 6) INTO s from dual;
  PRINT s;
END//;
CALL test_left();

CREATE PROCEDURE test_log() AS
//BEGIN
  DECLARE n double;
  SELECT LOG(2.0) INTO n from dual;
  PRINT n;
END//;
CALL test_log();

CREATE PROCEDURE test_replace() AS
//BEGIN
  UPDATE orders1 SET description = REPLACE(description, 'adescription', 'cdescription');
  select description from orders1;
END//;
CALL test_replace();

CREATE PROCEDURE test_day() AS
//BEGIN
  DECLARE d INT;
  SELECT day('2015-03-13') INTO d from dual;
  PRINT d;
END//;
CALL test_day();

CREATE PROCEDURE test_char2() AS
//BEGIN
  DECLARE c STRING;
  SELECT char(65) INTO c from dual;
  PRINT c;
END//;
CALL test_char2();

CREATE PROCEDURE test_second() AS
//BEGIN
  DECLARE s float;
  SELECT second('2008-04-21 08:15:00.000000') INTO s from dual;
  PRINT s;
END//;
CALL test_second();

CREATE PROCEDURE test_row_number() AS
//BEGIN
	SELECT row_number() over(order by item) from orders1;
END//;
CALL test_row_number();

CREATE PROCEDURE test_user() AS
//BEGIN
  DECLARE s STRING;
  SELECT user INTO s from dual;
  PRINT s;
END//;
CALL test_user();

CREATE PROCEDURE test_trim2() AS
//BEGIN
  DECLARE s STRING;
  SELECT TRIM(' Robert ') INTO s from dual;
  PRINT s;
END//;
CALL test_trim2();

CREATE PROCEDURE test_insert() AS
//BEGIN
  UPDATE orders1 SET description = INSERT (description, 6, 6, ' ption') WHERE description = 'bdescription';
  select description from orders1;
END//;
CALL test_insert();

CREATE PROCEDURE test_concat2() AS 
//BEGIN
  DECLARE s STRING;
  SELECT concat('a','b') INTO s from dual;
  PRINT s;
END//;
CALL test_concat2();

CREATE PROCEDURE test_lead() AS
//BEGIN
	SELECT item,description,lead(item,1,'ddescription') over ( order by item ) from orders1;
END//;
CALL test_lead();

create or replace procedure test_count() as //
DECLARE
   count1 int;
BEGIN
   SELECT COUNT(*) INTO count1 FROM emp;
   PRINT count1;
END//;
CALL test_count();

create or replace procedure test_avg() as //
DECLARE
   avg1 emp.salary%type;
BEGIN
   SELECT AVG(salary) INTO avg1 FROM emp;
   PRINT avg1;
END//;
CALL test_avg();

create or replace procedure test_sum() as //
DECLARE
   sum1 emp.salary%type;
BEGIN
   SELECT SUM(salary) INTO sum1 FROM emp;
   PRINT sum1;
END//;
CALL test_sum();

create or replace procedure test_min() as //
DECLARE
   min1 emp.salary%type;
BEGIN
   SELECT MIN(salary) INTO min1 FROM emp;
   PRINT min1;
END//;
CALL test_min();

create or replace procedure test_max() as //
DECLARE
   max1 emp.salary%type;
BEGIN
   SELECT MAX(salary) INTO max1 FROM emp;
   PRINT max1;
END//;
CALL test_max();

create or replace procedure test_stddev() as //
DECLARE
   std1 DOUBLE;
   std2 DOUBLE;
   std3 DOUBLE;
BEGIN
   SELECT STDDEV(salary) INTO std1 FROM emp LIMIT 1;
   PRINT std1;
   SELECT STDDEV(DISTINCT salary) INTO std2 FROM emp LIMIT 1;
   PRINT std2;
   SELECT STDDEV(salary,1.2) INTO std3 FROM emp LIMIT 1;
   PRINT std3;
END//;
CALL test_stddev();

create or replace procedure test_esgyn_decode() as //
DECLARE
   c1 CHAR(10);
   c2 CHAR(10);
BEGIN
   SELECT JOB_ID INTO c2 FROM EMP LIMIT 1;
   SELECT DECODE(job_id,'AD_VP','VP','FI_MGR','MGR','PU_MAN','MAN','MK_REP','REP','OTHERS') INTO c1 FROM emp LIMIT 1;
   PRINT C1;
   PRINT C2;
END//;
CALL test_esgyn_decode();

CREATE OR REPLACE PROCEDURE test_bool_hplsql() AS //
declare 
	b1 bool = true;
	b2 boolean = false;
BEGIN
  set b1 = false;
  set b2 = true;
  if b2 then
    PRINT 'ok';
  else
    PRINT 'failed';
  end if;
END//;
CALL test_bool_hplsql();

CREATE OR REPLACE PROCEDURE test_file_type() as //
DECLARE
   f UTL_FILE.FILE_TYPE;
   f2 UTL_FILE.FILE_TYPE;
   n1 VARCHAR(100);
BEGIN
   PRINT 'file_type test';
   f := UTL_FILE.FOPEN('/tmp','new_hello.txt','w');
   UTL_FILE.PUT(f,'1 hello world');
   UTL_FILE.PUT_LINE(f,'2 hello world');
   UTL_FILE.FCLOSE(f);
   f2 := UTL_FILE.FOPEN('/tmp','new_hello.txt','r');
   UTL_FILE.GET_LINE(f2,n1,200);
   PRINT 'n1' + n1;
END//;
CALL test_file_type();

CREATE OR REPLACE PROCEDURE mytest_exit() AS //
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
    PRINT 'mytest_exit Error raised, outer handler';

  BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      PRINT 'mytest_exit Error raised, resignal';
      RESIGNAL;
    END;
    PRINT 'mytest_exit Before executing SQL';
    SELECT * FROM TEST_PLSQL.TEST_1;
    PRINT 'mytest_exit After executing SQL not be printed';
  END;
  PRINT 'mytest_exit Continue outer block after exiting inner';
END//;
CALL mytest_exit();

CREATE OR REPLACE PROCEDURE mytest_continue() AS //
BEGIN
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    PRINT 'mytest_continue Error raised, outer handler';

  BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      PRINT 'mytest_continue Error raised, resignal';
      RESIGNAL;
    END;
    PRINT 'mytest_continue Before executing SQL';
    SELECT * FROM TEST_PLSQL.TEST_1;
    PRINT 'mytest_continue After executing SQL not be printed';
  END;
  PRINT 'mytest_continue Continue outer block after exiting inner';
END//;
CALL mytest_continue();

CREATE OR REPLACE PROCEDURE mytest2() AS //
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    	GET DIAGNOSTICS EXCEPTION 1 text = MESSAGE_TEXT;
        GET DIAGNOSTICS var_name = ROW_COUNT;
  	PRINT 'mytest2 SQLSTATE: ' || SQLSTATE;
        PRINT 'ROW_COUNT:' || var_name;
    PRINT 'mytest2 Text: ' || text;
  END; 
 
  BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
      RESIGNAL SQLSTATE '02031' SET MESSAGE_TEXT = 'Some error';
    SELECT * FROM abc;    
  END;
END//;
CALL mytest2();

CREATE OR REPLACE PROCEDURE mytest3() AS //
BEGIN
    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
            insert into test_results values('mytest3 Error raised');
            RESIGNAL;
    END;
    insert into test_results values ('mytest3 Before executing SQL');
    SELECT * FROM abc;
    insert into test_results values('mytest3 After executing SQL - will not be printed in case of error');
END//;
BEGIN WORK;
CALL mytest3();
select * from test_results;
COMMIT;

CREATE PROCEDURE test_set_session() as
//BEGIN
	DECLARE s string;
	DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
            PRINT 'SEABASE.TB_TEST TABLE NOT EXIST';
	SET SCHEMA = 'seabase';
	select a into s from tb_test;
	print s;
	SET CURRENT_SCHEMA = 'sch';
	select a into s from tb_test;
	SET SCHEMA = 'sea' || 'base';
	select a into s from tb_test;
	print s; 
END//;
CALL test_set_session();

CREATE PROCEDURE test_values() AS
//BEGIN
	DECLARE code varchar2(1);
	DECLARE count1 int;
	DECLARE limit1 int;
	VALUES 'A' INTO code;
	VALUES (0, 100) INTO (count1, limit1); 
	PRINT code;
  PRINT count1;
  PRINT limit1;
END//;
CALL test_values();

CREATE PROCEDURE test_declare_condition_exit() AS //
BEGIN
        DECLARE cnt INT DEFAULT 0;
        DECLARE wrong_cnt_condition CONDITION;

        DECLARE EXIT HANDLER FOR wrong_cnt_condition
                PRINT 'declare_cindition_exit Wrong number of rows';

        SELECT COUNT(*) INTO cnt FROM orders1;

        IF cnt <> 1 THEN
                SIGNAL wrong_cnt_condition;
        END IF;
END//;
CALL test_declare_condition_exit();

CREATE PROCEDURE test_declare_condition_continue() AS //
BEGIN
        DECLARE cnt INT DEFAULT 0;
        DECLARE wrong_cnt_condition CONDITION;

        DECLARE CONTINUE HANDLER FOR wrong_cnt_condition
                PRINT 'declare_cindition_continue Wrong number of rows';

        SELECT COUNT(*) INTO cnt FROM orders1;

        IF cnt <> 1 THEN
                SIGNAL wrong_cnt_condition;
        END IF;
END//;
CALL test_declare_condition_continue();

CREATE PROCEDURE test_declare_cursor() AS //
BEGIN
        DECLARE id STRING;
        DECLARE cur CURSOR FOR SELECT item FROM orders1;
        OPEN cur;
        FETCH cur INTO id;
        WHILE SQLCODE=0 THEN
          PRINT id;
          FETCH cur INTO id;
        END WHILE;
        CLOSE cur;
END//;
CALL test_declare_cursor();

CREATE PROCEDURE test_declare_cursor2() AS //
BEGIN
        DECLARE tabname VARCHAR DEFAULT 'orders1';
        DECLARE id STRING;
        DECLARE cur CURSOR FOR 'SELECT item FROM ' || tabname;
        OPEN cur;
        FETCH cur INTO id;
        WHILE SQLCODE=0 THEN
          PRINT id;
          FETCH cur INTO id;
        END WHILE;
        CLOSE cur;
END//;
CALL test_declare_cursor2();

-- CREATE PROCEDURE test_declare_handler_exit() AS //
--   DECLARE name VARCHAR(100);
--   DECLARE no_rows INT DEFAULT 0; 
--    
--   DECLARE EXIT HANDLER FOR NOT FOUND
--     SET no_rows = 1;    
--    
--   OPEN cur FOR 'SELECT item FROM orders1';
--    
--   FETCH cur INTO name;
--   WHILE no_rows = 0 THEN  
--     INSERT INTO tb_declare_handler VALUES(name);
--     FETCH cur INTO name;
--   END WHILE;
--   CLOSE cur;
-- end//;

CREATE PROCEDURE test_declare_handler_continue() AS //
BEGIN
  DECLARE name VARCHAR(100);
  DECLARE no_rows INT DEFAULT 0; 
  OPEN cur FOR 'SELECT item FROM orders1';
   
  FETCH cur INTO name;
  WHILE SQLCODE = 0 THEN  
    PRINT name;
    FETCH cur INTO name;
  END WHILE;
  CLOSE cur;
end//;
CALL test_declare_handler_continue();

CREATE PROCEDURE test_case() AS
//BEGIN
  DECLARE state varchar2(10) := 'AZ';
  DECLARE s_case varchar2(10);
  SELECT CASE state
   WHEN 'AZ' THEN 'Arizona'
   WHEN 'CA' THEN 'California'
   ELSE 'N/A'
  END INTO s_case;
  PRINT s_case;
END//;
CALL test_case();

CREATE PROCEDURE test_operators() AS 
//BEGIN
  IF 3=3 THEN
    PRINT '3=3 TRUE';
  ELSE
    PRINT '3=3 FALSE';
  END IF;
  IF 3=1 THEN
    PRINT '3=1 TRUE';
  ELSE
    PRINT '3=1 FALSE';
  END IF;
  IF 'CA'=NULL THEN
    PRINT 'CA=NULL TRUE';
  ELSE
    PRINT 'CA=NULL FALSE';
  END IF;
  IF 3==3 THEN
    PRINT '3==3 TRUE';
  ELSE
    PRINT '3==3 FALSE';
  END IF;
  IF 3<>3 THEN
    PRINT '3<>3 TRUE';
  ELSE
    PRINT '3<>3 FALSE';
  END IF;
  IF 3!=3 THEN
    PRINT '3!=3 TRUE';
  ELSE
    PRINT '3!=3 FALSE';
  END IF;
  IF 3>1 THEN
    PRINT '3>1 TRUE';
  ELSE
    PRINT '3>1 FALSE';
  END IF;
  IF 3<1 THEN
    PRINT '3<1 TRUE';
  ELSE
    PRINT '3<1 FALSE';
  END IF;
  IF 3>=1 THEN
    PRINT '3>=1 TRUE';
  ELSE
    PRINT '3>=1 FALSE';
  END IF;  
  IF 3<=1 THEN
    PRINT '3<=1 TRUE';
  ELSE
    PRINT '3<=1 FALSE';
  END IF;
END//;
CALL test_operators();

CREATE PROCEDURE test_hostcode() AS
//BEGIN
  declare s1 varchar(20);
  select s into s1 from tb_hostcode;
  PRINT ACTIVITY_COUNT; 
  select * from tb_hostcode;
  declare s_errorcode varchar(20) = errorcode;
  PRINT s_errorcode;
  HOST 'echo hello, world';
  IF HOSTCODE <> 0 THEN
    PRINT "HOSTCODE ERROR";
  END IF;
END//;
CALL test_hostcode();

CREATE OR REPLACE PROCEDURE spOpenIssues1() DYNAMIC RESULT SETS 1 as//
BEGIN
  DECLARE cur CURSOR WITH RETURN FOR
    SELECT item, description FROM orders1;
  OPEN cur;
END//;

CREATE OR REPLACE PROCEDURE spOpenIssues11() as //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
      
  CALL trafodion.sch.spOpenIssues1;
  ALLOCATE c1 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues1;

  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
END//;
CALL spOpenIssues11();

CREATE OR REPLACE PROCEDURE spOpenIssues12() as //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE loc RESULT_SET_LOCATOR VARYING;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
      
  CALL trafodion.sch.spOpenIssues1;
  ASSOCIATE RESULT SET LOCATOR (loc) WITH PROCEDURE trafodion.sch.spOpenIssues1;
  ALLOCATE c1 CURSOR FOR RESULT SET loc;
   
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
END//;
CALL spOpenIssues12();


CREATE or replace PROCEDURE spOpenIssues2() DYNAMIC RESULT SETS 2 AS //
BEGIN
    DECLARE cur CURSOR WITH RETURN FOR
      SELECT item, description FROM orders1;
    DECLARE cur2 CURSOR WITH RETURN FOR
      SELECT item, description FROM ORDERS2;
    OPEN cur;
    OPEN cur2;
END//;

CREATE or replace PROCEDURE spOpenIssues21() AS //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  CALL trafodion.sch.spOpenIssues2;
  ALLOCATE c1 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;
  
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
   
  ALLOCATE c2 CURSOR FOR PROCEDURE trafodion.sch.spOpenIssues2;
  FETCH c2 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c2 INTO item, description;
  END WHILE;
  CLOSE c2;
END//;
call spOpenIssues21();

CREATE or replace PROCEDURE spOpenIssues22() AS //
BEGIN
  DECLARE item VARCHAR(30);
  DECLARE description VARCHAR(30);
  DECLARE loc1 RESULT_SET_LOCATOR VARYING;
  DECLARE loc2 RESULT_SET_LOCATOR VARYING;
   
  CALL trafodion.sch.spOpenIssues2;
  ASSOCIATE RESULT SET LOCATOR (loc1, loc2) WITH PROCEDURE trafodion.sch.spOpenIssues2;
  
  DECLARE CONTINUE HANDLER FOR NOT FOUND
      set sqlcode = 1;

  ALLOCATE c1 CURSOR FOR RESULT SET loc1;
  FETCH c1 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c1 INTO item, description;
  END WHILE;
  CLOSE c1;
   
  ALLOCATE c2 CURSOR FOR RESULT SET loc2;
  FETCH c2 INTO item, description;
  WHILE (SQLCODE = 0)
  DO
    PRINT item || ' - ' || description;
    FETCH c2 INTO item, description;
  END WHILE;
  CLOSE c2;
END//;
call spOpenIssues22();

CREATE PROCEDURE test_include() as//
begin
INCLUDE $$QUOTE$$$$scriptsdir$$/udr/set_message.sql$$QUOTE$$;
 
DECLARE str STRING;
CALL set_message('world', str);
PRINT str;
end//;
CALL test_include();

create procedure test_interval() as//
begin
print DATE '2015-03-12' + 1 DAY;
print TIMESTAMP '2015-03-12' + 1 DAY;
print DATE '2015-03-12' + NVL(NULL, 3) DAYS;
print TIMESTAMP '2015-03-12' + NVL(NULL, 3) DAYS;
print TIMESTAMP '2015-03-12 10:10:10.000' - 1 MICROSECOND; 
print TIMESTAMP '2015-03-12' - 1 DAY - 1 MICROSECOND;
print date '2016-01-27' - interval '3' day;
end//;
call test_interval();

?section clean
DROP TABLE orders1;
DROP TABLE tab1;
DROP TABLE seabase.tb_test;
DROP TABLE orders2;
DROP TABLE emp;
DROP TABLE TB_HOSTCODE;
DROP TABLE TEST_RESULTS;
DROP TABLE trafodion.seabase.t_test_use;
DROP TABLE table_t1;
DROP TABLE table_t2;

DROP SCHEMA t_schema;

DROP PROCEDURE test_defining_variables;
DROP PROCEDURE test_defining_variables2;
DROP PROCEDURE test_trim;
DROP PROCEDURE test_to_timestamp;
DROP PROCEDURE test_to_char;
DROP PROCEDURE test_sysdate;
DROP PROCEDURE test_temp;
DROP PROCEDURE test_schema;
DROP PROCEDURE test_desc;
DROP PROCEDURE test_null;
DROP PROCEDURE test_drop_table_1;
DROP PROCEDURE test_drop_table_2;
DROP PROCEDURE test_use;
DROP PROCEDURE test_dbms_output_put_line;
DROP PROCEDURE test_instr;
DROP PROCEDURE test_timestamp_iso;
DROP PROCEDURE test_replace_2;
DROP PROCEDURE test_substr;
DROP PROCEDURE test_len;
DROP PROCEDURE test_length;
DROP PROCEDURE test_nvl2;
DROP PROCEDURE test_nvl;
DROP PROCEDURE test_now;
DROP PROCEDURE test_lower;
DROP PROCEDURE test_upper;
DROP PROCEDURE test_decode;
DROP PROCEDURE test_date;
DROP PROCEDURE test_current_user;
DROP PROCEDURE test_current_timestamp;
DROP PROCEDURE test_current_date;
DROP PROCEDURE test_concat;
DROP PROCEDURE test_coalesce;
DROP PROCEDURE test_char;
DROP PROCEDURE test_cast;
DROP PROCEDURE test_rowtype_type;
DROP PROCEDURE test_exception_block;
DROP PROCEDURE test_dynamicSQL;
DROP PROCEDURE test_fetch;
DROP PROCEDURE test_cursor_attributes;
DROP PROCEDURE test_close;
DROP PROCEDURE test_while;
DROP PROCEDURE test_leave;
DROP PROCEDURE test_ifelse;
DROP PROCEDURE test_for;
DROP PROCEDURE test_for_cursorloop;
DROP PROCEDURE test_exit_when;
DROP PROCEDURE test_exit_when2;
DROP PROCEDURE test_flow_control;
DROP PROCEDURE test_from_unixtime;
DROP PROCEDURE test_unix_timestamp;
DROP PROCEDURE test_char2;
DROP PROCEDURE test_day;
DROP PROCEDURE test_replace;
DROP PROCEDURE test_log;
DROP PROCEDURE test_left;
DROP PROCEDURE test_substring;
DROP PROCEDURE test_cast2;
DROP PROCEDURE test_right;
DROP PROCEDURE test_second;
DROP PROCEDURE test_row_number;
DROP PROCEDURE test_user;
DROP PROCEDURE test_trim2;
DROP PROCEDURE test_insert;
DROP PROCEDURE test_concat2;
DROP PROCEDURE test_lead;
DROP PROCEDURE test_count;
DROP PROCEDURE test_avg;
DROP PROCEDURE test_sum;
DROP PROCEDURE test_min;
DROP PROCEDURE test_max;
DROP PROCEDURE test_stddev;
DROP PROCEDURE test_esgyn_decode;
DROP PROCEDURE test_file_type;
DROP PROCEDURE mytest_exit;
DROP PROCEDURE mytest_continue;
DROP PROCEDURE mytest2;
DROP PROCEDURE mytest3;
DROP PROCEDURE test_values;
DROP PROCEDURE test_set_session;
DROP PROCEDURE test_declare_condition_continue;
DROP PROCEDURE test_declare_condition_exit;
DROP PROCEDURE test_declare_cursor;
DROP PROCEDURE test_declare_cursor2;
DROP PROCEDURE test_declare_handler_continue;
-- DROP PROCEDURE test_declare_handler_exit;
DROP PROCEDURE test_case;
DROP PROCEDURE test_bool_hplsql;
DROP PROCEDURE test_operators;
DROP PROCEDURE test_hostcode;
DROP PROCEDURE SPOPENISSUES1;
DROP PROCEDURE SPOPENISSUES11;
DROP PROCEDURE SPOPENISSUES12;
DROP PROCEDURE SPOPENISSUES2;
DROP PROCEDURE SPOPENISSUES21;
DROP PROCEDURE SPOPENISSUES22;
DROP PROCEDURE TEST_INCLUDE;
DROP PROCEDURE test_interval;
drop table if exists t1;
DROP PROCEDURE p1;
