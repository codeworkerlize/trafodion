-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@

obey TEST310(clean);
obey TEST310(setup);

log LOG310 clear;

obey TEST310(test);

log;

obey TEST310(clean);
exit;

?section setup

set terminal_charset utf8;

create schema t310sch;

?section test

set schema t310sch;

--
-- Mantis 16081 [assignment] 使用SET (var [, var2, ...]) = (SELECT col [, col2, ... ] FROM ...);赋值语句，执行SPSQL时返回java.lang.NumberFormatException异常错误
--

create or replace procedure m16081p1() as //
declare
   code char(3) := 'A';
   status int = 1;
   count1 int;
   limit1 int default -1;
begin
   print('code = '||code);
   print('status = '||status);
   print('count1 = '||count1);
   print('limit1 = '||limit1);
   
   set code = (select 'C' from dual);
   set status=(select 3 from dual), count1=(select 3 from dual);
   set (count1, limit1) = (select 4,300 from dual);
   print('code = '||code);
   print('status = '||status);
   print('count1 = '||count1);
   print('limit1 = '||limit1);
end//;

call m16081p1();

---
--- Mantis 13293 Expression evaluated in the wrong orde in if statement
---

create or replace procedure m13293p1() as //
begin
  print(10-1+2-3*4-5+6);
  print(10-1+2-3*(4-5)+6);
end//;

call m13293p1();

--
-- Mantis 13127 An error occurred when the stored procedure encountered "'case \' | code"
--

create or replace procedure m13127p1() as //
begin
  select 'a\b\c\' from dual;
end//;

call m13127p1();

--
-- Mantis 12584 SPSQL compatible treat empty string as null
-- Mantis 12783 SPSQL function NVL() wrong result if variable is NULL
--

create or replace procedure m12584p1() as //
declare
  vEmpty varchar(10) := '';
  vNull varchar(10) := null;
begin
  if vEmpty = vNull then
    print 'vEmpty == vNull';
  else
    print 'vEmpty != vNull';
  end if;

  if vNull = vEmpty then
    print 'vNull == vEmpty';
  else
    print 'vNull != vEmpty';
  end if;

  if vEmpty is null then
    print 'vEmpty is null';
  else
    print 'vEmpty is not null';
  end if;

  if vEmpty = null then
    print 'vEmpty == null';
  else
    print 'vEmpty != null';
  end if;

  if vEmpty = '' then
    print 'vEmpty == empty';
  else
    print 'vEmpty != empty';
  end if;

  if vNull is null then
    print 'vNull is null';
  else
    print 'vNull is not null';
  end if;

  if vNull = null then
    print 'vNull == null';
  else
    print 'vNull != null';
  end if;

  if vNull = '' then
    print 'vNull == empty';
  else
    print 'vNull != empty';
  end if;
end//;

create or replace procedure m12783p1() as //
declare
  vNull varchar(20);
  vEmpty varchar(20) := '';
begin
  print nvl(null, 'null is null');
  print nvl('', 'empty is null');
  print nvl(vEmpty, 'vEmpty is null');
  print nvl(vNull, 'vNull is null');

  print nvl2(null, 'null is not null', 'null is null');
  print nvl2('', 'empty is not null', 'empty is null');
  print nvl2(vEmpty, 'vEmpty is not null', 'vEmpty is null');
  print nvl2(vNull, 'vNull is not null', 'vNull is null');
end//;


EXECUTE //
SET "hplsql.empty.is.null" = true;
//;

call m12584p1();
call m12783p1();

EXECUTE //
SET "hplsql.empty.is.null" = false;
//;

call m12584p1();
call m12783p1();

--
-- Test case for Mantis-11365
--

create or replace function m11365f1(a int) return int as //
begin
  return a*2;
end//;

exec //
print m11365f1(123);
//;

--
-- Test UPDATE/DELETE with variables
--

drop table if exists udt1;
create table udt1 (a int, b int, c varchar(30));
insert into udt1 values (1, 1, 'aaa'),(2, 2, 'bbb'),(3, 3, 'ccc');
create or replace procedure update_with_var(pa int, pb int, pc varchar(10)) as //
begin
  update udt1 set b=b+10*pb where a=pa;
  update udt1 set b=b+100*pb, c=c||pc where a=pa;
  update udt1 set (b,c) = (b+1000*pb,c||pc) where a=pa;
  update udt1 set (b,c) = (select b+10000*pb,c||pc from udt1 where a=pa+1) where a=pa-1;
  update udt1 set c = (select c||pc from udt1 where a=pa) where a=pa+1;
end
//;

call update_with_var(2, 2, 'BBB');
select * from udt1;

create or replace procedure delete_with_var(pa int) as //
begin
  delete from udt1 where a = pa + 1;
end
//;

call delete_with_var(2);
select * from udt1;

--
-- Test SELECT GROUP BY AND ORDER BY clause with variables
--

drop table if exists t301_t1;
create table t301_t1(a int, b varchar(10));
insert into t301_t1 values(1, 'hello');
insert into t301_t1 values(2, 'hello');
insert into t301_t1 values(3, 'hello');
insert into t301_t1 values(11, 'world');
insert into t301_t1 values(12, 'world');
create or replace procedure select_clause_with_var() as//
begin
  declare c varchar = 'a';
  declare d int = 1;

  select * from t301_t1 order by d;

  select a from t301_t1 group by d;
  select a from t301_t1 order by d;
  select a, substr(b,3) || c from t301_t1 group by substr(b,3) || c, a;
  select a, substr(b,3) || c from t301_t1 order by substr(b,3) || c, a;
end//;
call select_clause_with_var();

--
-- Test [NOT] IN operation
--
create or replace procedure t310_in() as //
declare
  a int := 3;
  b varchar := 'hello';
  c double := 12.3;
begin
  if a in (1,2,3,4,5) then
    print a || ' IN (1,2,3,4,5)';
  end if;
  if a not in (1,2,4,5) then
    print a || ' NOT IN (1,2,4,5)';
  end if;
  if b in ('hello', 'world') then
    print b || ' IN (hello, world)';
  end if;
  if b NOT in ('Hello', 'World') then
    print b || ' NOT IN (Hello, World)';
  end if;
  if c in (1.23, 3.12, 12.3) then
    print c || ' IN (1.23, 3.12, 12.3)';
  end if;
  if c not in (1.23) then
    print c || ' NOT IN (1.23)';
  end if;
  if 1.23 in (1.23) then
    print '1.23 IN (1.23)';
  end if;
  if '1.23' in (1.23) then
    print '''1.23'' IN (1.23)';
  end if;
  if 1.23 in ('1.23') then
    print '1.23 IN (''1.23'')';
  end if;
end//;

call t310_in();

CREATE OR REPLACE PROCEDURE t310_in_bool() AS //
BEGIN
  IF true IN (true, true) THEN
    PRINT 'PASS';
  ELSE
    PRINT 'FAIL';
  END IF;
  IF true IN (false, true) THEN
    PRINT 'PASS';
  ELSE
    PRINT 'FAIL';
  END IF;
  IF false NOT IN (true, true) THEN
    PRINT 'PASS';
  ELSE
    PRINT 'FAIL';
  END IF;
  IF true NOT IN (false, true) THEN
    PRINT 'FAIL';
  ELSE
    PRINT 'PASS';
  END IF;
  IF false NOT IN (false, true) THEN
    PRINT 'FAIL';
  ELSE
    PRINT 'PASS';
  END IF;
  IF false NOT IN ('false', 'true', 0, 1) THEN
    PRINT 'PASS';
  ELSE
    PRINT 'FAIL';
  END IF;
  IF true NOT IN ('false', 'true', 0, 1) THEN
    PRINT 'PASS';
  ELSE
    PRINT 'FAIL';
  END IF;
END//;

call t310_in_bool();

CREATE OR REPLACE PROCEDURE t310_in_datetime() AS //
BEGIN
  IF DATE('2019-06-08') IN (DATE '2019-06-08') THEN
    print 'PASS';
  ELSE
    print 'FAIL';
  END IF;
  IF DATE('2019-06-08') IN (DATE '2019-06-07', DATE '2018-06-08', TIMESTAMP '2018-06-08 12:00:00.123456') THEN
    print 'FAIL';
  ELSE
    print 'PASS';
  END IF;
  IF TIMESTAMP '2019-06-08 12:00:00.123456' NOT IN (TIMESTAMP '2019-06-08 12:00:00.123456') THEN
    print 'FAIL';
  ELSE
    print 'PASS';
  END IF;
  IF TIMESTAMP '2019-06-08 12:00:00.123456'
     NOT IN (TIMESTAMP '2019-06-08 12:00:00.123455'
            ,TIMESTAMP '2019-06-08 12:00:01.123456'
            ,TIMESTAMP '2019-06-08 12:00:01.12345'
            ,TIMESTAMP '2019-06-08 12:00:01'
            ,TIMESTAMP '2019-06-07 12:00:00.123456'
            ,TIME '12:00:00.123456'
            ,DATE '2019-06-08')
  THEN
    print 'PASS';
  ELSE
    print 'FAIL';
  END IF;
  IF TIME '12:00:00.123456' NOT IN (TIME '12:00:00.123456') THEN
    print 'FAIL';
  ELSE
    print 'PASS';
  END IF;
  IF TIME '12:00:00.123456'
    NOT IN (TIME '12:00:00.12346'
           ,TIME '12:00:00.1234'
           ,TIME '12:00:00'
           ,TIMESTAMP '2019-06-08 12:00:00.123456')
  THEN
    print 'PASS';
  ELSE
    print 'FAIL';
  END IF;
END//;

call t310_in_datetime();

--
-- Test SUBSTR function
--
create procedure t310_substr(out a varchar(10),
                             out b varchar(10),
                             out c varchar(10),
                             out d varchar(10),
                             out e varchar(10),
                             out f varchar(10),
                             out g varchar(10),
                             out h varchar(10),
                             out i varchar(10),
                             out j varchar(10),
                             out k varchar(10),
                             out l varchar(10),
                             out m varchar(10),
                             out n varchar(10),
                             out o varchar(10),
                             out p varchar(10)) as //
declare
  s varchar := 'ABCDEFGHIJ';
begin
  set a := substr(s, 0, 3);
  set b := substr(s, 1, 3);
  set c := substr(s, 5, 10);
  set d := substr(s, 9, 2);
  set e := substr(s, 10, 1);
  set f := substr(s, 11, 1);
  set g := substr(s, 11, 1);
  set h := substr(s, 2, 0);
  set i := substr(s, 11, 0);
  set j := substr(s, -1, 1);
  set k := substr(s, -3, 2);
  set l := substr(s, 5, 20);
  set m := substr(s, -3, 20);
  set n := substr(s, -3, 0);
  set o := substr(s, -3, -1);
  set p := substr(s, 1, -10);
end//;

call t310_substr(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);

--
-- Test SUBSTR FROM FOR function
--
create procedure t310_substr_from(out a varchar(10),
                                  out b varchar(10),
                                  out c varchar(10),
                                  out d varchar(10),
                                  out e varchar(10),
                                  out f varchar(10),
                                  out g varchar(10),
                                  out h varchar(10),
                                  out i varchar(10),
                                  out j varchar(10),
                                  out k varchar(10),
                                  out l varchar(10),
                                  out m varchar(10),
                                  out n varchar(10),
                                  out o varchar(10),
                                  out p varchar(10)) as //
declare
  s varchar := 'ABCDEFGHIJ';
begin
  set a := substr(s from 0  for 3);
  set b := substr(s from 1  for 3);
  set c := substr(s from 5);
  set d := substr(s from 9  for 2);
  set e := substr(s from 10 for 1);
  set f := substr(s from 11 for 1);
  set g := substr(s from 11 for 1);
  set h := substr(s from 2  for 0);
  set i := substr(s from 11 for 0);
  set j := substr(s from -1 for 1);
  set k := substr(s from -3 for 2);
  set l := substr(s from 5  for 20);
  set m := substr(s from -3 for 20);
  set n := substr(s from -3 for 0);
  set o := substr(s from -3 for -1);
  set p := substr(s from 1  for -10);
end//;

call t310_substr_from(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);

--
-- Test for mantis-11398 function with utf8/ucs2 param
--
set terminal_charset utf8;

create or replace function f1(a varchar(10) character set utf8)
  return varchar(10) character set utf8 as //
begin
  return '你好，' || a || '!';
end//;

select f1('易鲸捷') from dual;
select f1('Esgyn') from dual;

create or replace function f2(a varchar(10) character set ucs2)
  return varchar(10) character set ucs2 as //
begin
  return '你好，' || a || '!';
end//;

select f2('易鲸捷') from dual;
select f2('Esgyn') from dual;

--
-- Test for mantis-11397 package function with utf8/ucs2 param
--
set terminal_charset utf8;

create or replace package pkg1 as//
  function f1(a varchar(10) character set utf8)
    return varchar(10) character set utf8;
  function f2(a varchar(10) character set ucs2)
    return varchar(10) character set ucs2;
end//;

create or replace package body pkg1 as//
  function f1(a varchar(10) character set utf8)
    return varchar(10) character set utf8 as
  begin
    return '你好，' || a || '!';
  end;

  function f2(a varchar(10) character set ucs2)
    return varchar(10) character set ucs2 as
  begin
    return '你好，' || a || '!';
  end;
end//;

select pkg1.f1('易鲸捷') from dual;
select pkg1.f1('Esgyn') from dual;

select pkg1.f2('易鲸捷') from dual;
select pkg1.f2('Esgyn') from dual;

--
-- Test SYS_CONTEXT function
--
create procedure t310_sys_context() as //
begin
  print  sys_context('userenv', 'session_user');
  print  sys_context('userenv', 'host');
  print  sys_context('userenv', 'ip_address');
  print  sys_context('userenv', 'sessionid');
  select sys_context('userenv', 'session_user'),
         sys_context('userenv', 'host'),
         sys_context('userenv', 'ip_address'),
         sys_context('userenv', 'sessionid') from dual;
end//;

call t310_sys_context();

--
-- Mantis 11948
--

create table if not exists m11948t1 (a int);
create or replace function m11948f1(a timestamp) return varchar(8) as //
begin
  return '20190808';
end//;

create or replace procedure m11948p1(a int) as //
begin
  b := m11948f1(a);
exception
  when others then
  begin
    insert into m11948t1 (a) values (a);
  end;
end//;

create or replace procedure m11948p2(a timestamp) as //
begin
  null;
end//;

create or replace procedure m11948p3(a int) as //
begin
  m11948p2(a);
exception
  when others then
  begin
    insert into m11948t1 (a) values (a);
  end;
end//;

call m11948p1(11948);
select * from m11948t1;
call m11948p3(11948);
select * from m11948t1;

--
-- Mantis 12044 EXECUTE IMMEDIATE INTO
--

create table m12044t1 (a int);

create procedure m12044p1() as //
declare
  va int;
begin
  declare continue handler for not found
    print 'NOT FOUND';

  declare continue handler for sqlexception
  begin
    get diagnostics exception 1 errmsg = message_text;
    print 'SQLEXCEPTION: ' || errmsg;
  end;

  execute immediate 'select a from m12044t1' into va;
  print activity_count;
  print va;

  insert into m12044t1 values (12044);
  execute immediate 'select a from m12044t1' into va;
  print activity_count;
  print va;

  execute immediate 'select a from m12044t1' into v_not_exist;
  print activity_count;
  print v_not_exist;

  insert into m12044t1 values (12044);
  execute immediate 'select a from m12044t1' into va;
  print activity_count;
  print va;

  execute immediate 'select a from not_exist_table' into va;
  print activity_count;
  print va;
end//;

call m12044p1();


drop table if exists "m12038t1" cascade;
create table if not exists "m12038t1"
(
"oper_desc" varchar(30),
"oper_query" varchar(600)
);
insert into "m12038t1" values(NULL,NULL);
insert into "m12038t1" values(NULL, 'delete');

create or replace procedure m12038p1() as //
declare
  i VARCHAR(30);
begin
  select cast(count(*) as varchar(30)) into i from "m12038t1" where "oper_desc" is NULL and "oper_query" is NULL;
  insert into "m12038t1" ("oper_desc", "oper_query") values ('insert'||i, 'insert');
  update "m12038t1" set "oper_desc" = 'update' where "oper_query" is NULL;
  delete from "m12038t1" where "oper_query"='delete';
end//;

call m12038p1();
select * from "m12038t1" order by "oper_desc";

--
-- Mantis 12176 Support minus and upsert
--
create table m12176t1(a int);
insert into m12176t1 values(1);
insert into m12176t1 values(1);
insert into m12176t1 values(2);
insert into m12176t1 values(2);
create table m12176t2(a int);
insert into m12176t2 values(2);
insert into m12176t2 values(2);
insert into m12176t2 values(3);
insert into m12176t2 values(3);

create procedure m12176p1() as//
begin
  select * from m12176t1 minus select * from m12176t2;
  select * from m12176t1 except select * from m12176t2;
  select * from m12176t1 intersect select * from m12176t2;
  select * from m12176t1 union select * from m12176t2;
  select * from m12176t1 union all select * from m12176t2;
end//;
call m12176p1();

create procedure m12176p2() as//
begin
  upsert into m12176t1 values(4);
  upsert using load into m12176t1 values(5);
  upsert into m12176t1 select 6 from dual;
  upsert using load into m12176t1 select 7 from dual;
end//;
call m12176p2();
select * from m12176t1;

--
-- Mantis 12278 Support variable in ON clause
--

create table m12278t1 (a int, b varchar(10));
create table m12278t2 (a int, b varchar(10));

insert into m12278t1 values (1, 'a');
insert into m12278t1 values (2, 'b');
insert into m12278t1 values (3, 'c');

insert into m12278t2 values (1, 'A');
insert into m12278t2 values (2, 'B');
insert into m12278t2 values (3, 'C');

create or replace procedure m12278p1() as //
declare
  v_a int := 2;
begin
  select t1.*, t2.*
    from m12278t1 t1 left join m12278t2 t2
    on t1.a = t2.a and t1.a = v_a;
end//;

call m12278p1();

--
-- Mantis 12283 function will not rollback after call function fail
--

create table m12283t1 (a int primary key, b boolean);
create or replace function m12283f1() return int as //
begin
  insert into m12283t1 values (1, true);
  /* This will fail */
  insert into m12283t1 values (1, false);
end//;

select m12283f1() from dual;
select * from m12283t1;

--
-- Mantis 12361 Custom function execution appears core
--

create table m12361t1 (a varchar(10));
insert into m12361t1 values ('a'), ('b'), ('c');

create or replace function m12361f1(a varchar2(30000)) return int as //
begin
  return 1;
end//;

select m12361f1(a) from m12361t1;

--
-- Mantis 12166 Function still get the old data when the function was
-- recreated in another session
--

create or replace function m12166f1() return int as //
begin
  return 1;
end//;

select m12166f1() from dual;

sh sqlci -q "create or replace function t310sch.m12166f1() return int as //begin return 10; end//;";

select m12166f1() from dual;

--
-- Mantis 12567 Fetch/Select no data cannot exit loop
--

create table m12567t1 (a int);
create or replace procedure m12567p1() as //
declare
  va int;
begin
  loop
    select a into va from m12567t1;
  end loop;
end//;

call m12567p1();

--
-- Mantis 12782 funciton LENGTH cause NullPointerException
--

create or replace procedure m12782p1() as //
begin
  print char(null);
  print instr('abc', null);
  print instr(null, 'a');
  print instr(null, null);
  print instr('abcabcabc', 'c', 5, 2);
  print instr('abcabcabc', 'c', null, 2);
  print instr('abcabcabc', 'c', 5, null);
  print instr('abcabcabc', 'c', null, null);
  print instr('abcabcabc', 'c', '5', '2');
  print len(null);
  print length(null);
  print lower(null);
  print replace('abcde', 'b', null);
  print replace('abcde', null, 'B');
  print replace('abcde', null, null);
  print replace(null, 'b', 'B');
  print replace(null, null, 'B');
  print replace(null, null, null);
  print substr('abcde', 2, null);
  print substr('abcde', null, 3);
  print substr('abcde', null, null);
  print substr(null, 2, 3);
  print substr(null, null, 3);
  print substr(null, null, null);
  print substr('abcabcabc', '3', '5');
  print substring('abcabcabc', '3', '5');
  print substring('abcabcabc' from '3' for '5');
  print trim(null);
  print to_char(null);
  print upper(null);
end//;

call m12782p1();

exec // instr('abcabcabc', 'c', '5a', '2'); //;
exec // instr('abcabcabc', 'c', '5', '2a'); //;

exec // substr('abcabcabc', '3a', '5'); //;
exec // substr('abcabcabc', '3', '5a'); //;

exec // substring('abcabcabc', '3a', '5'); //;
exec // substring('abcabcabc', '3', '5a'); //;

exec // substring('abcabcabc' from '3a' for '5'); //;
exec // substring('abcabcabc' from '3' for '5a'); //;

--
-- Mantis 12963 call procedure with unsupported data type params will core dump
--

create or replace procedure m12963p1(i smallint, out h smallint) as //
begin
  set h = i;
end//;

call m12963p1(1, ?);

--
-- Mantis 11112 REAL data type with cursor will cause ERROR[11220]
--

create table m11112(v_real real);
insert into m11112 values(0.5);
create or replace procedure m11112p1() as //
declare
  var_real real;
  cursor c1 is select * from m11112;
begin
  open c1;
  fetch c1 into var_real;
  print var_real;
  close c1;
end//;
call m11112p1();

--
-- Mantis 10958 :new:col_nam in trigger can not cause an error when create trigger, and it will cause insert get error [3049]
--

drop table if exists t_10958;
create table if not exists t_10958(c1 int);
create or replace procedure p10958() as //
begin
  insert into t_10958 values (1);
end//;
call p10958();
create or replace procedure p10958() as //
begin
  insert into t_10958 values (t.c1);
end//;
call p10958();
create or replace procedure p10958() as //
begin
  insert into t_10958 values (:t.c1);
end//;
call p10958();
drop table if exists t_10958;
drop procedure p10958;      

--
-- Mantis 12233 Stored Procedures Write File Content in Chinese with Chaotic Code
--

create table m12233t1 (a varchar(50) character set utf8);
create or replace procedure m12233p1() as //
declare
  s1 varchar(50);
  s2 varchar(50);
  s3 varchar(50);
  f1 UTL_FILE.FILE_TYPE;
  f2 UTL_FILE.FILE_TYPE;
begin
  f1 := UTL_FILE.FOPEN('/tmp', 'm12233file.txt', 'w');
  UTL_FILE.PUT_LINE(f1, 'Mantis 12233 测试字符串1!');
  UTL_FILE.PUT_LINE(f1, 'Mantis 12233 测试字符串2!');
  UTL_FILE.PUT_LINE(f1, 'Mantis 12233 测试字符串3!');
  UTL_FILE.FCLOSE(f1);
  f2 := UTL_FILE.FOPEN('/tmp', 'm12233file.txt', 'r');
  UTL_FILE.GET_LINE(f2, s1, 50);
  insert into m12233t1 values (s1);
  UTL_FILE.GET_LINE(f2, s2, 50);
  insert into m12233t1 values (s2);
  UTL_FILE.GET_LINE(f2, s3, 50);
  insert into m12233t1 values (s3);
end//;

call m12233p1();
select * from m12233t1;

--
-- Mantis 12834 SPSQL length () returns incorrect result when the column type is char/nchar/national char
--

create table m12834t1 (c1 char(10) character set iso88591,
                       c2 char(10) character set utf8,
                       c3 char(10) character set ucs2,
                       c4 varchar(10) character set iso88591,
                       c5 varchar(10) character set utf8,
                       c6 varchar(10) character set ucs2);

insert into m12834t1 values ('Esgyn', '易鲸捷', '易鲸捷', 'Esgyn', '易鲸捷', '易鲸捷');

select length(c1), length(c2), length(c3),
       length(c4), length(c5), length(c6) from m12834t1;

create or replace procedure m12834p1() as //
begin
  for item in select * from m12834t1 loop
    print(length(item.c1));
    print(length(item.c2));
    print(length(item.c3));
    print(length(item.c4));
    print(length(item.c5));
    print(length(item.c6));
  end loop;
end//;

call m12834p1();

create table test_ly(a int, b int);
insert into test_ly values(1,1);
create or replace procedure m14921()
as
//
begin
delete from test_ly a where a.b=1;
end;//;

create or replace procedure m14921_1()
as
//
begin
select * from test_ly a where a.b=1;
end;//;

call m14921_1();
call m14921();

--
-- Mantis 14922 存储过程变量赋值转换
--

create or replace procedure m14922p1() as //
declare
  a int;
  b varchar(8);
begin
  a = '3';
  b = 3;

  print a;
  print b;

  if a = b then
    print 'pass';
  else
    print 'fail';
  end if;

  if b = a then
    print 'pass';
  else
    print 'fail';
  end if;
end//;

call m14922p1();

--
-- Mantis 15890 字符与整数使用> , >=比较符时返回结果不正确
-- Mantis 15899 字符与小数使用>, >=, <, <= 比较符时导致call procedure 返回Details: java.sql.SQLException错误
--

create or replace procedure m15890p1() as //
declare
  a int;
begin
  print '11.23' + 20.3;
  print 20 + '11.23';
  print ' 11.23 ' + 20;
  a = '11.23' + 20;
  print a;
  a = 20 + ' 11.23 ';
  print a;
  a = 20.8 + '11.23 ';
  print a;
  a = '11.23' + 20.8;
  print a;

  if ' 11.0 ' = 11 then
    print 'pass';
  else
    print 'fail';
  end if;

  if 11 = ' 11.00 ' then
    print 'pass';
  else
    print 'fail';
  end if;

  if 11.0 = ' 11.00 ' then
    print 'pass';
  else
    print 'fail';
  end if;

  if 10.1 > '10.00' then
    print('pass');
  else
    print('fail');
  end if;

  if 10.0 < '10.01' then
    print('pass');
  else
    print('fail');
  end if;

  if 10 < '10.01' then
    print('pass');
  else
    print('fail');
  end if;

  if 10 <= '10' then
    print('pass');
  else
    print('fail');
  end if;

  if 10 <= '10.00' then
    print('pass');
  else
    print('fail');
  end if;

  if '10.1' > 10 then
    print('pass');
  else
    print('fail');
  end if;

  if '11' > 10 then
    print('pass');
  else
    print('fail');
  end if;

  if '11' >= 10 then
    print('pass');
  else
    print('fail');
  end if;

  if '11' >= 11 then
    print('pass');
  else
    print('fail');
  end if;

  if 11 > '10' then
    print('pass');
  else
    print('fail');
  end if;

  if 11 >= '10' then
    print('pass');
  else
    print('fail');
  end if;

  if 11 >= '11' then
    print('pass');
  else
    print('fail');
  end if;
end//;

call m15890p1();

--
-- Mantis 15905 字符与整数使用<, <=比较符, 条件不成立时返回结果不正确
--

create or replace procedure m15905p1() as //
begin
  if 'a' > 11 then
    null;
  end if;
end//;

-- ERROR 11220 number format error
call m15905p1();

--
-- Mantis 16092 spsql 变量名使用双引号，执行spsql时返回Details: java.sql.SQLException: at most one declaration for 'abc' is permitted.错误
--

create or replace procedure m16092p1() as //
declare
   abc int;
   "abc" int;
begin
   abc = 1;
   "abc" = 2;
   
   print('abc = '|| abc);
   print('"abc" = '||"abc");
end//;

call m16092p1();

--
-- Mantis 16103 [declare] 定义变量指定NOT NULL 无效， 仍然可以给变量赋值为NULL
--

create or replace procedure m16103p1() as //
declare
  count1 smallint not null := 3;
begin
   declare continue handler for sqlexception
   begin
     GET DIAGNOSTICS EXCEPTION 1 errmsg = MESSAGE_TEXT;
     print 'Error: ' + errmsg;
   end;

   count1 = null;
   count1 := null;
   set count1 = null;
   select null into count1 from dual;
   declare count2 smallint not null;
end//;

call m16103p1();

--
-- Mantis 16212 存储过程执行整数数学运算,会出现小数点
--

create or replace PROCEDURE m16212p1() as //
declare
  v_a int;
  v_b varchar(20);
begin
  v_a:=20;
  select to_number(nvl(cast(v_a as varchar(20)),'0'))-1 into v_b from dual;
  print v_b;
end//;

call m16212p1();

--
-- Mantis 16741 [RegressionIssue]使用情况时，语句赋值，当条件表达式中常量与然后常量而不是同一类型且当条件不成立时，返回java.sql.SQLException：数字格式错误错误
--

create or replace PROCEDURE m16741p1() as //
declare
  v1 varchar(20);
  v2 int;
begin
   v1 = case 3
           when 0 then 'failed'
           when 1 then 'failed'
           else 'correct'
         end ;
   print v1;

   v2 = case 'a'
           When 'b' then 1
           when 'c' then 2
           else 3
         end ;
   print v2;
end//;

call m16741p1();

--
-- Mantis 13546 The application cannot read the DDL of the changed stored procedure
--

create or replace procedure m13546p1() as //
begin
  print 'Hello';
end//;

create or replace package body m13546pkg as //
  procedure p1
  begin
    print 'Hello';
  end;

  procedure p2
  begin
    print 'World';
  end;
end//;

call m13546p1();
call m13546pkg.p1();

sh sqlci -i "TEST310(replace1)";

call m13546p1();
call m13546pkg.p1();
call m13546pkg.p2();

sh sqlci -i "TEST310(replace2)";

-- ERROR 4302
call m13546p1();
call m13546p1('Esgyn');
call m13546pkg.p1();
call m13546pkg.p2();

sh sqlci -i "TEST310(replace3)";

call m13546p1('Esgyn');
call m13546pkg.p1();
call m13546pkg.p2();

sh sqlci -i "TEST310(replace4)";

call m13546p1('Esgyn');
-- ERROR 4302
call m13546pkg.p1();
call m13546pkg.p1('Esgyn');
call m13546pkg.p2();

?section replace1
set schema t310sch;
create or replace procedure m13546p1() as //
begin
  print 'Hi';
end//;

?section replace2
set schema t310sch;
create or replace procedure m13546p1(in a varchar(20)) as //
begin
  print 'Hi, ' || a;
end//;

?section replace3
set schema t310sch;
create or replace package body m13546pkg as //
  procedure p1
  begin
    print 'Hi';
  end;

  procedure p2
  begin
    print 'There';
  end;
end//;

?section replace4
set schema t310sch;
create or replace package body m13546pkg as //
  procedure p1 (in a varchar(20))
  begin
    print 'Hi, ' || a;
  end;

  procedure p2
  begin
    print 'There';
  end;
end//;

?section clean

drop schema if exists t310sch cascade;
