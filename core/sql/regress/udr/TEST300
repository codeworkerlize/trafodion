-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@

obey TEST300(clean);
obey TEST300(setupauth);

log LOG300 clear;

obey TEST300(utf8);
obey TEST300(priv);
obey TEST300(setup);
obey TEST300(test);
obey TEST300(showddltest);

-- The result set test case will be run several times with different
-- result sets number
obey TEST300(rssetup);
set pattern $$NUM$$ 0;
obey TEST300(resultset);
set pattern $$NUM$$ 1;
obey TEST300(resultset);
set pattern $$NUM$$ 2;
obey TEST300(resultset);
set pattern $$NUM$$ 3;
obey TEST300(resultset);
set pattern $$NUM$$ 255;
obey TEST300(resultset);

-- Test PRINT statement
obey TEST300(print);

obey TEST300(anonymous);
obey TEST300(sch);
obey TEST300(loadtest);

log;
obey TEST300(clean);
exit;

?section showddltest

drop procedure if exists p1;
create procedure p1(in a varchar(100), out b varchar(100)) as //
begin
  set b = 'Hello ' || b || '!';
end//;

showddl procedure p1;

drop function if exists f1;
create function f1(a int) return (f1 int) as //
begin
  return a * 2;
end//;

showddl function f1;

create or replace package pkg is //
  procedure hello(in name varchar(30) character set utf8,
                  out greeting varchar(30) character set utf8);
end;
//;

create or replace package body pkg is //
  procedure hello(in name varchar(30) character set utf8,
                  out greeting varchar(30) character set utf8) is
  begin  
    set greeting = 'Hello, ' || name || '!';
  end;
end;
//;

showddl package pkg;

?section utf8

set terminal_charset utf8;

create or replace procedure hello(in name varchar(30) character set utf8,
                                  out greeting varchar(30) character set utf8) as //
begin
  set greeting = '你好，' || name || '！';
end//;

showddl procedure hello;

create or replace package pkg is //
  procedure hello(in name varchar(30) character set utf8,
                  out greeting varchar(30) character set utf8);
end;
//;

create or replace package body pkg is //
  procedure hello(in name varchar(30) character set utf8,
                  out greeting varchar(30) character set utf8) is
  begin  
    set greeting = name ||'，你好！';
  end;
end;
//;

showddl package pkg;

call hello('易鲸捷', ?);
call pkg.hello('易鲸捷', ?);

set terminal_charset iso88591;

?section setupauth

initialize authorization;
register user sql_user1 as sql_user1;
register user sql_user2 as sql_user2;

?section priv

create procedure t300p1() as //
begin
  print 'Hello';
end//;

call t300p1();

sh sqlci -i "TEST300(priv1)" -u sql_user2;

grant execute on procedure t300p1 to sql_user2;

sh sqlci -i "TEST300(priv1)" -u sql_user2;

?section priv1

set schema $$TEST_SCHEMA$$;
log LOG300;

call t300p1();
drop procedure t300p1;

?section sch

create schema t300sch1;
set schema t300sch1;

create table ts1 (a varchar(50));

create function f1(a varchar(50)) return (f1 varchar(50)) as //
begin
  insert into ts1 values (a);
  return a;
end//;

create procedure p1() as //
begin
  insert into ts1 values('t300sch1.p1');
  p2();
end//;

create procedure p2() as //
begin
  insert into ts1 values('t300sch1.p2');
end//;

set schema $$TEST_SCHEMA$$;

drop table if exists ts;
drop procedure if exists p1;
drop procedure if exists f1;
drop procedure if exists t300p;
create table ts (a varchar(50));

create procedure p1() as //
begin
  insert into ts values('p1');
  t300sch1.p1();
  trafodion.t300sch1.p1();
end//;

create procedure t300p() as //
begin
  insert into ts values('t300p');
  p1();
  t300sch1.p1();
  insert into ts values('t300p');
  p1();
  trafodion.t300sch1.p1();
  insert into ts values('t300p');
  p1();
  select t300sch1.f1('t300p') from dual;
  select trafodion.t300sch1.f1('t300p') from dual;
  select t300sch1.f1(a) from ts;
  select trafodion.t300sch1.f1(a) from ts;

  set schema t300sch1;
  insert into ts1 values('t300p');
  select f1('t300p') from dual;
  select t300sch1.f1('t300p') from dual;
  select trafodion.t300sch1.f1('t300p') from dual;
  select f1(a) from $$TEST_SCHEMA$$.ts;
  select t300sch1.f1(a) from $$TEST_SCHEMA$$.ts;
  select trafodion.t300sch1.f1(a) from $$TEST_SCHEMA$$.ts;
  p1();
end//;

call t300p();

select * from ts;
select * from t300sch1.ts1;

?section anonymous

drop table if exists t1;
create table t1 (a int);

exec //
begin
  insert into t1 values (1);
end
//;

exec //
declare
  a INT := 2;
begin
  insert into t1 values (a);
end
//;

execute // insert into t1 values (3) //;

select * from t1;

?section rssetup
drop table if exists t1;
drop table if exists t2;
drop procedure if exists p1;
create table t1 (a int);
insert into t1 values (1),(2),(3);
create table t2 (b int);
insert into t2 values (4),(5),(6);

?section print
create or replace procedure p1() as //
declare
  i int := 1;
  s varchar(100) := 'Hello';
begin
  declare continue handler for sqlexception
  begin
    print sqlcode;
    print sqlcode;
    print sqlstate;
    print sqlstate;
  end;
  PRINT i;
  PRINT 1+1;
  PRINT s;
  PRINT 'Hi';
  select * from table_not_exit;
  select 1 into i from dual;
  print activity_count;
  print activity_count;
end//;

call p1();

?section resultset
create or replace procedure p1() dynamic result sets $$NUM$$ as //
begin
  select * from t1;
  select * from t2;
end//;

-- Call the procedure twice to make sure the result sets are cleared
-- before each call
call p1();
call p1();

?section setup

reset parserflags 131072;
initialize trafodion, upgrade library management;
-- Test upgrading can update the internal SPJs
select COLUMN_SIZE from TRAFODION."_MD_".COLUMNS where OBJECT_UID=(select OBJECT_UID from TRAFODION."_MD_".OBJECTS where OBJECT_NAME='CREATESPSQL');
set parserflags 131072;
update TRAFODION."_MD_".COLUMNS set COLUMN_SIZE=1000000 where OBJECT_UID=(select OBJECT_UID from TRAFODION."_MD_".OBJECTS where OBJECT_NAME='CREATESPSQL');
select COLUMN_SIZE from TRAFODION."_MD_".COLUMNS where OBJECT_UID=(select OBJECT_UID from TRAFODION."_MD_".OBJECTS where OBJECT_NAME='CREATESPSQL');
reset parserflags 131072;
initialize trafodion, upgrade library management;
select COLUMN_SIZE from TRAFODION."_MD_".COLUMNS where OBJECT_UID=(select OBJECT_UID from TRAFODION."_MD_".OBJECTS where OBJECT_NAME='CREATESPSQL');

create table users (name varchar(100));
create procedure adduser(in name varchar(100), out cnt int) as //
declare
  query varchar(1000);
begin
  query := 'select count(*) from users';
  insert into users values(name);
  execute immediate query into cnt;
end//;

create procedure plus(in a int, in b int, out c int) as //begin set c = a + b; end//;
create procedure concat(in s varchar(100), inout t varchar(100)) as //begin set t = s || ', ' ||  t; end//;

-- The catalog is wrong, will trigger error on invocation
create procedure adduserBad1(in name varchar(100)) as //
begin
  insert into trafodin.sch.users values(name);
end//;

-- Syntax error in SP body
-- expect error 1231
create procedure adduserBad2(in name varchar(100)) as //
begin
  insert into trafodin.sch.users value(name);
end//;

create procedure addFloat(in a float, in b float, out c float) as //begin set c = a + b; end//;
create procedure subFloat(in a float, in b float, out c float) as //begin set c = a - b; end//;
create procedure mulFloat(in a float, in b float, out c float) as //begin set c = a * b; end//;
create procedure divFloat(in a float, in b float, out c float) as //begin set c = a / b; end//;

create procedure addFloatInt(in a float, in b int, out c float) as //begin set c = a + b; end//;
create procedure subFloatInt(in a float, in b int, out c float) as //begin set c = a - b; end//;
create procedure mulFloatInt(in a float, in b int, out c float) as //begin set c = a * b; end//;
create procedure divFloatInt(in a float, in b int, out c float) as //begin set c = a / b; end//;

create procedure addIntFloat(in a int, in b float, out c float) as //begin set c = a + b; end//;
create procedure subIntFloat(in a int, in b float, out c float) as //begin set c = a - b; end//;
create procedure mulIntFloat(in a int, in b float, out c float) as //begin set c = a * b; end//;
create procedure divIntFloat(in a int, in b float, out c float) as //begin set c = a / b; end//;

create procedure addReal(in a real, in b real, out c real) as //begin set c = a + b; end//;
create procedure subReal(in a real, in b real, out c real) as //begin set c = a - b; end//;
create procedure mulReal(in a real, in b real, out c real) as //begin set c = a * b; end//;
create procedure divReal(in a real, in b real, out c real) as //begin set c = a / b; end//;

create procedure addDecimal(in a decimal(9,3), in b decimal(9,3), out c decimal(9,3)) as //begin set c = a + b; end//;
create procedure subDecimal(in a decimal(9,3), in b decimal(9,3), out c decimal(9,3)) as //begin set c = a - b; end//;
create procedure mulDecimal(in a decimal(9,3), in b decimal(9,3), out c decimal(9,3)) as //begin set c = a * b; end//;
create procedure divDecimal(in a decimal(9,3), in b decimal(9,3), out c decimal(9,3)) as //begin set c = a / b; end//;

create procedure getSysDate(out t TIMESTAMP) as //begin set t = sysdate; end//;

create procedure selectIntoDate(out d DATE) as //
begin
  select current_date into d from dual;
end//;
create procedure selectIntoTimestamp(out t TIMESTAMP) as //
begin
  select current_timestamp into t from dual;
end//;
create procedure selectIntoTime(out t TIME) as//
begin
  select current_time into t from dual;
end//;

create or replace procedure castFunc (out a char(50), out b numeric(10,2)) as //
declare
   n1 double := 123.45;
   n2 char(50) := '543.21';
begin
   select cast(n1 as char(64)) into a from dual;
   select cast(n2 as numeric(10,2)) into b from dual;
end//;

-- create table
drop table if exists t1;
create table t1(a1 int);
insert into t1(a1) values(1);
select * from t1;

?section test

select * from users;
call adduser('Trafodion', ?);
select * from users;

-- expect error 11218
call adduserBad1('Blabla');
select * from users;

-- expect error 1389
call adduserBad2('Blablabla');
select * from users;

call plus(1,2,?);

set param ?p 'world';
call concat('hello ', ?p);

call addFloat(101.32, 212.839265, ?);
call subFloat(101.32, 212.839265, ?);
call mulFloat(101.32, 212.839265, ?);
call divFloat(101.32, 212.839265, ?);

call addFloatInt(101.32, 212, ?);
call subFloatInt(101.32, 212, ?);
call mulFloatInt(101.32, 212, ?);
call divFloatInt(101.32, 212, ?);

call addIntFloat(101, 212.839265, ?);
call subIntFloat(101, 212.839265, ?);
call mulIntFloat(101, 212.839265, ?);
call divIntFloat(101, 212.839265, ?);

call addReal(101.32, 212.839265, ?);
call subReal(101.32, 212.839265, ?);
call mulReal(101.32, 212.839265, ?);
call divReal(101.32, 212.839265, ?);

call addDecimal(1, 2, ?);
call subDecimal(1, 2, ?);
call mulDecimal(1, 2, ?);
call divDecimal(1, 2, ?);

call addDecimal(111111.111, 222222.222, ?);
call subDecimal(111111.111, 222222.222, ?);
call mulDecimal(111111.111, 222222.222, ?);
call divDecimal(111111.111, 222222.222, ?);

call addDecimal(111111.1119, 222222.2229, ?);
call subDecimal(111111.1119, 222222.2229, ?);
call mulDecimal(111111.1119, 222222.2229, ?);
call divDecimal(111111.1119, 222222.2229, ?);

call getSysDate(?);
call selectIntoDate(?);
call selectIntoTimestamp(?);
call selectIntoTime(?);

call castFunc(?,?);

-- Test TO_TIME function
create table totime(l1 varchar(60),l2 char(24),l3 time);
create procedure totimeFunc() as //
declare
   c1 char(20) := '17:01:23';
begin
   insert into totime values ('c1',c1,null);
   insert into totime select 'TO_TIME(c1,''HH24:MI:SS'') is',c1,TO_TIME(c1,'HH24:MI:SS') from dual;
   insert into totime values ('TO_TIME(c1,'||''''||'HH24:MI:SS'||''''||') is',c1,TO_TIME(c1,'HH24:MI:SS'));
end//;

call totimeFunc();
select * from totime;

drop PROCEDURE if exists plus_one;

-- should fail
CREATE OR REPLACE PROCEDURE if NOT EXISTS plus_one(para1 INT)
LANGUAGE SQL AS //
BEGIN
update t1 set a1 = a1 + 1;
END //;


CREATE PROCEDURE plus_one(para1 INT)
LANGUAGE SQL AS //
BEGIN
update t1 set a1 = a1 + 1;
END //;

-- CALL
call plus_one(1);

-- check the result
select * from t1;

-- CALL
call plus_one(1);

-- check the result
select * from t1;

CREATE OR REPLACE PROCEDURE plus_one(para1 INT)
LANGUAGE SQL AS //
BEGIN
update t1 set a1 = a1 * 2;
END //;

-- CALL
call plus_one(1);

-- check the result
select * from t1;

-- CALL
call plus_one(1);

-- check the result
select * from t1;

--
-- test cases for functions
--
drop table if exists t1;
create table t1 (a int, b int);
insert into t1 values (1,1),(2,2),(3,3),(4,4),(5,5);

drop table if exists t2;
create table t2 (c int);

drop function if exists f1;
create function f1(a int, b int) returns (f1 int) as //
begin
  declare  c int;
  c := a + b;
  if c < 10 then 
    insert into t2 values (c);
  end if;
  return c;
end//;

begin work;
select f1(a, b) from t1;
rollback;
select * from t2;
select * from t1;

begin work;
select f1(a, b) from t1;
commit;
select * from t2;
select * from t1;

-- support LOOP in SPSQL
CREATE OR REPLACE PROCEDURE test_loop() AS //
BEGIN
    declare x int := 0;
    LOOP
        x = x + 1;
        print(x);
        if x == 3
            break;
    end loop;
END//;

call test_loop();

-- create or replace function
create or replace function f1(a int) return (f1 int) as //
begin
  return a * 2;
end//;

select f1(1) from dual;

create or replace function f1(a int) return (f1 int) as //
begin
  return a * 3;
end//;

select f1(1) from dual;

?section loadtest

drop procedure if exists t300p;
drop procedure if exists t300p1;
drop function if exists t300f;
drop package if exists t300pkg;
drop table if exists t1;

create table t1 (a int);
insert into t1 values (1),(2),(3);

obey TEST300(loadcall);

sh sqlci -i "TEST300(loadtest1)";

obey TEST300(loadcall);

sh sqlci -i "TEST300(loadtest2)";

exec //invalidate procedure t300p//;
obey TEST300(loadcall);

exec //invalidate function t300f//;
obey TEST300(loadcall);

exec //invalidate package t300pkg//;
obey TEST300(loadcall);

exec //invalidate all//;
obey TEST300(loadcall);

?section loadcall

call t300p(?);
call t300pkg.hello(?);
select t300f(a) from t1;

?section loadtest1

set schema $$TEST_SCHEMA$$;
log LOG300;

create procedure t300p(out a varchar(100)) as //
begin
  set a = 't300p';
  t300p1(a);
end//;

create procedure t300p1(inout a varchar(100)) as //
begin
  set a = a || ' t300p1';
end//;

create function t300f(a int) return (t300f int) as //
begin
  return a * 2;
end//;

create package body t300pkg as //
  procedure hello(out a varchar(100)) is
  begin
    set a = 'Hello';
  end;
end//;

?section loadtest2

set schema $$TEST_SCHEMA$$;
log LOG300;

create or replace procedure t300p(out a varchar(100)) as //
begin
  set a = 'T300P';
  t300p1(a);
end//;

create or replace procedure t300p1(inout a varchar(100)) as //
begin
  set a = a || ' T300P1';
end//;

create or replace function t300f(a int) return (t300f int) as //
begin
  return a * 3;
end//;

create or replace package body t300pkg as //
  procedure hello(out a varchar(100)) is
  begin
    set a = 'Hi';
  end;
end//;

?section clean
drop schema if exists t300sch1 cascade;
drop table if exists ts;
drop procedure if exists p1;
drop procedure if exists t300p;
drop table users;
drop table t1;
drop table t2;
drop table totime;

drop procedure adduser;
drop procedure adduserBad1;
drop procedure adduserBad2;
drop procedure plus;
drop procedure concat;

drop procedure addFloat;
drop procedure subFloat;
drop procedure mulFloat;
drop procedure divFloat;

drop procedure addFloatInt;
drop procedure subFloatInt;
drop procedure mulFloatInt;
drop procedure divFloatInt;

drop procedure addIntFloat;
drop procedure subIntFloat;
drop procedure mulIntFloat;
drop procedure divIntFloat;

drop procedure addReal;
drop procedure subReal;
drop procedure mulReal;
drop procedure divReal;

drop procedure addDecimal;
drop procedure subDecimal;
drop procedure mulDecimal;
drop procedure divDecimal;

drop procedure getSysDate;
drop procedure selectIntoDate;
drop procedure selectIntoTimestamp;
drop procedure selectIntoTime;
drop procedure plus_one;

drop procedure castFunc;
drop procedure totimeFunc;

drop function f1;
drop procedure t300p1;
drop procedure hello;
drop function t300f;
