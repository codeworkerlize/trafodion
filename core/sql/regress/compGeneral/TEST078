-------------------------------------------------------------------------
-- Replica tests. This is replication within the same cluster and not xDC.
-- This test also does not include REGION_REPLICATION HBase option.
-- Simple test case to set up a table with replicas,
-- do simple inserts, updates, deletes, merges.
-------------------------------------------------------------------------
-- @@@ START COPYRIGHT @@@
--
-- Licensed to the Apache Software Foundation (ASF) under one
-- or more contributor license agreements.  See the NOTICE file
-- distributed with this work for additional information
-- regarding copyright ownership.  The ASF licenses this file
-- to you under the Apache License, Version 2.0 (the
-- "License"); you may not use this file except in compliance
-- with the License.  You may obtain a copy of the License at
--
--   http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing,
-- software distributed under the License is distributed on an
-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-- KIND, either express or implied.  See the License for the
-- specific language governing permissions and limitations
-- under the License.
--
-- @@@ END COPYRIGHT @@@


obey TEST078(clean_up);
log LOG078 clear;
obey TEST078(create_table);
obey TEST078(test_DML);
obey TEST078(test_DDL);
log;
obey TEST078(clean_up);
exit;


-- just test range partition table now, Because the functionality is not yet developed, 
-- the test case needs to specify which syntax is supported and which is not, and then modify the test case after it is completed

?section create_table

create schema testpartition;
set schema testpartition;

create table pt_range_test1(
  pid   numeric(10),
  pname varchar(30)
) partition by range(pid)(
  partition p1 values less than(1000),
  partition p2 values less than(2000)
);
create index idx1 on pt_range_test1(pid) local;

create table pt_range_test2(
  pid   numeric(10),
  pname varchar(30)
) partition by range(pid)(
  partition p1 values less than(1000),
  partition p2 values less than(2000)
);
create index idx2 on pt_range_test2(pid) local;

create table pt_range_test3(
  pid   numeric(10),
  pname varchar(30)
) partition by range(pid)(
  partition p1 values less than(1000),
  partition p2 values less than(2000),
  partition p3 values less than(MAXVALUE)
);

showddl pt_range_test1;
showddl pt_range_test2;
showddl pt_range_test3;
create table ta078 like  pt_range_test1;
create table tb078 like  pt_range_test2;
create table tc078 like  pt_range_test3;

showddl ta078;
showddl tb078;
showddl tc078;

create table pt_NOrange_test(
  pid   numeric(10),
  pname varchar(30)
);

create table if not exists pt_range_test_normal(c1 int);
create table if not exists pt_range_partition (c1 int,c2 int,c3 int, c4 varchar(10),primary key(c1,c2,c3))
partition by range(c1,c2,c3)
(partition p1 values less than (10,10,10),
partition p2 values less than (20,20,20),
partition p3 values less than (30,30,30));
create table if not exists partition1 (c1 int,c2 int,c3 int, c4 varchar(10),primary key(c1,c2));
create table if not exists partition2 (c1 int,c2 int,c3 int, c4 varchar(10),primary key(c1,c2,c3));

-- =====================alter table add partition=====================
-- wrong keywords, should be syntax error
alter table pt_range_partition add partitionn p4 values less than (40,40);
alter table pt_range_test_none add partition p1 values less than(1);
alter table pt_range_test_normal add partition p1 values less than (1);
alter table pt_range_partition add partition p4 values less than (40,40);
alter table pt_range_partition add partition p4 values less than (40,40,40,40);
alter table pt_range_partition add partition p4 values less than (40,40,'abc');
alter table pt_range_partition add partition p4 values less than ('40',40,40);
alter table pt_range_partition add partition p4 values less than (40,40,40);
alter table pt_range_partition add partition p5 values less than (50,50,50);
alter table pt_range_partition add partition p6 values less than (50,50,50);
alter table pt_range_partition add partition p5 values less than (50,50,60);
alter table pt_range_partition add partition p6 values less than (50,50,60);
showddl pt_range_partition;
--alter table add mutiple partitions
create table part_test_alter1(c1 int, c2 int, c3 int)
  partition by range(c1, c2, c3) (
  partition p1 values less than (10, 10, 10),
  partition p2 values less than (20, 20, maxvalue));
alter table part_test_alter1 add partition p3 values less than (30, 30, maxvalue),
  partition p4 values less than (40, maxvalue, maxvalue);

-- =====================alter table unmount partition=====================
alter table pt_range_test_none unmount partition p1;
alter table pt_range_test_normal unmount partition p1;
alter table pt_range_partition unmount partition p1;
showddl pt_range_partition;
showddl part_pt_range_partition_p1_;
alter table pt_range_partition unmount partition p2,p3,p4;
showddl pt_range_partition;
alter table pt_range_partition unmount partition p5,p6;
alter table pt_range_partition unmount partition for (1,1,1);
showddl pt_range_partition;
alter table pt_range_partition unmount partition for (100,100,100);
alter table pt_range_partition unmount partition for (20,20,20);
showddl pt_range_partition;

-- =====================alter table mount partition=====================
alter table pt_range_test_none mount partition part_pt_range_partition_p1_ values less than(100,100,100);
alter table pt_range_test_normal mount partition part_pt_range_partition_p1_ values less than(100,100,100);
alter table pt_range_partition mount partition part_pt_range_partition_p1_ values less than(100,100,100) into partition p1;
alter table pt_range_partition unmount partition p1;
showddl pt_range_partition;
alter table pt_range_partition mount partition partition1 values less than(100,100,100);
alter table pt_range_partition mount partition partition2 values less than(1,1,1);
insert into partition2 values(100,100,100,'a');
alter table pt_range_partition mount partition partition2 values less than(100,100,100);
alter table pt_range_partition mount partition partition2 values less than(100,100,100) without validation;
showddl pt_range_partition;
alter table pt_range_partition unmount partition partition2;
showddl pt_range_partition;
showddl partition2;
insert into partition2 values(10,10,10,'b'),(11,11,11,'c');
select * from partition2;
alter table pt_range_partition mount partition partition2 values less than(200,200,200);
showddl pt_range_partition;

-- =====================alter table drop partition=====================
create table pt_range_test4 (c1 int,c2 int,c3 int)
partition by range(c1)(
  partition p1 values less than (10),
  partition p2 values less than (20),
  partition p3 values less than (30),
  partition p4 values less than (40),
  partition p5 values less than (50),
  partition p6 values less than (60),
  partition p7 values less than (70),
  partition p8 values less than (80),
  partition pmax values less than (MAXVALUE)
);
showddl pt_range_test4;
alter table pt_range_test4 drop partition pmax;
showddl pt_range_test4;

-- ERROR: The specified partition <partName> does not exist
alter table pt_range_test4 drop partition p10;
alter table pt_range_test4 drop partition p1, p10;
alter table pt_range_test4 drop partition p10, for(5);

-- ERROR: The partition number is invalid or out-of-range
alter table pt_range_test4 drop partition for(100);
alter table pt_range_test4 drop partition for(5), for(100);
alter table pt_range_test4 drop partition p1, for(100);
alter table pt_range_test4 drop partition for(100), p10;

-- ERROR: The DDL request has duplicate references to partition name P1.
alter table pt_range_test4 drop partition p1,p1;
alter table pt_range_test4 drop partition p1, for(5);
-- ERROR: The DDL request has duplicate references to partition name .
alter table pt_range_test4 drop partition for(5), for(6);

-- ERROR: No partition exists after drop.
alter table pt_range_test4 drop partition p1, p2, p3, p4, p5, p6, p7, p8;
alter table pt_range_test4 drop partition for(5), for(15), for(25), for(35), for(45), for(55), for(65), for(75);
alter table pt_range_test4 drop partition p1, p2, p3, for(35), for(45), p6, p7, p8;

create index idx_test4 on pt_range_test4(c3) partition (p5);
showddl pt_range_test4;
explain options 'f' select c3 from pt_range_test4;
alter table pt_range_test4 drop partition p5,p7;
showddl pt_range_test4;

create index idx_test4 on pt_range_test4(c3) local;
showddl pt_range_test4;
explain options 'f' select c3 from pt_range_test4;

alter table pt_range_test4 drop partition for(15), for(35);
showddl pt_range_test4;
alter table pt_range_test4 drop partition p3, for(55), p8;
showddl pt_range_test4;

-- ERROR: Dropping the only partition of an object is not allowed.
alter table pt_range_test4 drop partition p1;
showddl pt_range_test4;

-- ========================== TRUNCATE =================================
create table if not exists pt1(c1 int, c2 int, c3 varchar(10), primary key(c1))
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30)
);
insert into pt1 partition (p1) values(1,1,'hahaha');
insert into pt1 partition (p2) values(11,11,'hehehe');
insert into pt1 partition (p3) values(21,21,'heiheihei');
select * from pt1;
alter table pt1 truncate partition p1;
alter table pt1 truncate partition for(11);
alter table pt1 truncate partition p3;
select * from pt1;
insert into pt1 partition (p1) values(1,1,'hahaha');
insert into pt1 partition (p2) values(11,11,'hehehe');
insert into pt1 partition (p3) values(21,21,'heiheihei');
truncate pt1;
select * from pt1;
create table if not exists pt2(c1 int, c2 numeric(10,2), c3 varchar(10), c4 date, primary key(c1)) attribute stored desc
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30),
partition pmax values less than (maxvalue)
);
insert into pt2 partition(p1) values(4, 10.5, 'pt1', '2021-04-23');
insert into pt2 partition(p2) values(14, 10.5, 'pt2', '2021-04-23');
insert into pt2 partition(p3) values(24, 10.5, 'pt3', '2021-04-23');
insert into pt2 partition(pmax) values(200, 10.5, 'maxvalue', '2021-04-23');
select * from pt2;
alter table pt2 truncate partition pmax;
select * from pt2;
truncate pt2;
select * from pt2;
insert into pt2 partition(p1) values(4, 10.5, 'pt1', '2021-04-23');
insert into pt2 partition(p2) values(14, 10.5, 'pt2', '2021-04-23');
insert into pt2 partition(p3) values(24, 10.5, 'pt3', '2021-04-23');
insert into pt2 partition(pmax) values(200, 10.5, 'maxvalue', '2021-04-23');
alter table pt2 truncate partitions p1,p2;
alter table pt2 truncate partition for(24),pmax;
select * from pt2;

-- ========================== RENAME ===================================
showddl pt1;
--three error test case should report error
alter table pt1 rename partition p1 to p1;
alter table pt1 rename partition p1 to p2;
alter table pt1 rename partition p4 to p4_temp;

alter table pt1 rename partition p1 to p1_temp;
alter table pt1 rename partition for(11) to p2_temp;
alter table pt1 rename partition for(21) to p3_temp;
showddl pt1;

showddl pt2;
alter table pt2 rename partition pmax to pmax_temp;
showddl pt2;

alter table pt2 rename to pt2_new;
showddl pt2_new;

--============================add/drop column===============================
create table pt3 (c1 int ,c2 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20)
);
alter table pt3 add column c3 int;
showddl pt3;
alter table pt3 drop column c3;
showddl pt3;

?section test_DML

-- ========================== INSERT ===================================

insert into pt_range_test1(pid, pname) values(1, 'aaa');
insert into pt_range_test1 partition(p1) values(1, 'aaa');
insert into pt_range_test1 partition for(10) values(1, 'aaa');
insert into pt_range_test1 partition for(10) select * from pt_range_test2;
insert into pt_range_test1 partition for(10) select * from pt_range_test2 partition(p1);
insert into pt_range_test1 partition for(10) select * from pt_range_test2 partition(p2);
insert into pt_range_test1 partition for(10) select * from pt_range_test2 partition for (1000);
insert into pt_range_test1 partition for(1050)  select * from pt_range_test2 partition(p1);


-- negetive test, all of follow SQL shoule be error.
insert into pt_range_test1 partition values(1, 'aaa');
insert into pt_range_test1 partition(p2) values(1, 'aaa');
insert into pt_range_test1 partition(p1) values(10000, 'aaa');
insert into pt_range_test1 partition for(1) t values(10000, 'aaa');
insert into pt_range_test1 partition for(10000) t values(1, 'aaa');
insert into pt_range_test1 partition for(10) select * from pt_range_test2 partition;
insert into pt_range_test1 partition for(10) t select * from pt_range_test2 partition for (10000);
insert into pt_range_test1 partition(p1) select element, element from udf(series(1,2002));
insert into pt_range_test1 select element, element from udf(series(1,2002));
create table testc as select * from pt_range_test1 partition(p3);

-- ========================== UPDATE ===================================
create table pt_range_test5(
  pid numeric(10),
  pname varchar(30),
  primary key(pid)
) partition by range(pid)(
  partition p1 values less than(1000),
  partition p2 values less than(2000)
);

update pt_range_test1 set pid = 10;
update pt_range_test1 partition(p1) set pid = 10;
update pt_range_test1 partition(p1) t set pid = 10;
update pt_range_test1 partition for (1) t set pid = 10;
update pt_range_test1 partition for (1001) t set pid = 10;
insert into pt_range_test1 values(1001, 'aaa');
update pt_range_test1 set pid=1010 where pid=1001;
update pt_range_test1 set pid=(select 1001 from dual) where pid=1010;
update pt_range_test1 set pid=3 where pid=10 or pid = 1001;

insert into pt_range_test5 values(1, 'hello');
update pt_range_test5 set pid=2 where pid=1;
update pt_range_test5 set pid=(select 1 from dual) where pid=2;
update pt_range_test5 set pid=1001 where pid=1;
insert into pt_range_test5 values(1001, 'hello1');
update pt_range_test5 set pid=3 where pid=1 or pid = 1001;
update pt_range_test5 set pid=pid+3;

insert into pt_range_test2 values (1, 'hello'),(2, 'hello'),(3, 'hello'),(1001, 'hello');
select * from (update pt_range_test2 partition (p1) set pname = 'try' return "NEW".pname) t(pname);
select * from (update pt_range_test2 set pname='try_try' where pid=1 return "OLD".pname) t(pname);
select * from (update pt_range_test2 set pname='try_try' where pid=2 return "NEW".pname) t(pname);
select * from (update pt_range_test2 set pname = 'try_try_try' return "OLD".pname) t(pname);

-- negetive test, all of follow SQL shoule be error.
update pt_range_test1 partition set pid = 10;
update pt_range_test1 partition(p1, p2) set pid = 10;
update pt_range_test1 partition(p1) t set pid = 10000;
update pt_range_test1 partition for (1, 2) t set pid = 10;
update pt_range_test1 partition for (10000) t set pid = 10;


-- ========================== SELECT ===================================

select * from pt_range_test1;
select * from pt_range_test1 partition(p1);
select * from pt_range_test1 partition(p1) t;
select * from pt_range_test1 partition for (100);
select * from pt_range_test1 partition for (1000);
select * from pt_range_test1 partition(p1) where pid > 1001;
select * from pt_range_test1 partition(p1) t1 join pt_range_test2 t2 on (t1.pid = t2.pid);
select * from pt_range_test1 partition(p1) t1 join pt_range_test2 partition(p1) t2 on (t1.pid = t2.pid);
select * from pt_range_test1 partition(p1) t1 join pt_range_test2 partition for (100) t2 on (t1.pid = t2.pid);
select * from pt_range_test1 partition for (10) t1 join pt_range_test2 partition for (100) t2 on (t1.pid = t2.pid);
create table testc as select * from pt_range_test1 partition(p1);

-- negetive test, all of follow SQL shoule be error.
select * from pt_range_test1 partition;
select * from pt_range_test1 partition t;
select * from pt_range_test1 partition for (2000) t;
select * from pt_range_test1 partition for ('asd');
select * from pt_range_test1 partition(p3);
select * from pt_range_test1 t partition(p1);
select * from pt_range_test1 partition(p1, p2) t;
select * from pt_range_test1 partition for (400, 1000);
select * from pt_range_test1 partition(p1) t1 join pt_range_test2 partition for (10, 1000) t2 on (t1.pid = t2.pid);
create table testc as select * from pt_range_test1 partition(p3);

-- for(null) test.
create table t1 (c1 int ,c2 int ,c3 int ,c4 int )
partition by range(c1,c2,c3)
(
partition p1 values less than (1,1,1),
partition p2 values less than (11,11,11),
partition p3 values less than (21,21,21)
);
select * from t1 partition for(null,1,1);
select * from t1 partition for(1,null,null);
select * from t1 partition for(null,null,null);
drop table t1;
create table pt_null2 (c1 int ,c2 int ,c3 int ,c4 int )
partition by range(c1,c2)
(
partition p1 values less than (10,10),
partition p2 values less than (20,20),
partition pmax values less than (maxvalue,maxvalue)
);
insert into pt_null2 values(1,null,null,null),(11,null,null,null),(null,null,null,null);
select * from pt_null2 partition for(1,null);
select * from pt_null2 partition for(11,null);
select * from pt_null2 partition for(null,null);
drop table pt_null2;
create table s2 (c1 int ,c2 int ,c3 int ,c4 int )
partition by range(c1,c2,c3)
(
partition p1 values less than (1,1,1),
partition p2 values less than (11,11,11),
partition p3 values less than (21,21,21),
partition pmax values less than (31,maxvalue,maxvalue)
);
insert into s2 values(30,30,30,30);
select * from s2 partition for(30,30,30);
select * from s2 partition for(31,31,31);
select * from s2 partition for(31,31,null);
select * from s2 partition for(31,null,null);
select * from s2 partition for(null,null,null);
drop table s2;
create table s4 (c1 int ,c2 int ,c3 int ,c4 int )
partition by range(c1,c2,c3)
(
partition p1 values less than (1,1,1),
partition p2 values less than (11,maxvalue,11),
partition p3 values less than (21,21,21),
partition pmax values less than (31,maxvalue,maxvalue)
);
insert into s4 values(0,1,1,1),(1,1,1,1),(11,11,11,11),(20,20,20,20),(21,21,21,21);
select * from s4 partition for(1,null,null);
select * from s4 partition for(11,null,null);
select * from s4 partition for(11,null,12);
select * from s4 partition for(11,11,null);
select * from s4 partition for(20,20,20);
select * from s4 partition for(21,null,null);
select * from s4 partition for(21,21,null);
select * from s4 partition for(31,null,null);
select * from s4 partition for(31,31,null);
drop table s4;

 -- =====================UPDATE STATISTICS =============================
update statistics for table pt_range_test1 partition(p1) on every column;
update statistics for table pt_range_test1 partition(p1) on every column if not exists;
update statistics for table pt_range_test2 like pt_range_test1;
update statistics for table pt_range_test1 partition for(10) on every column;
showstats for table pt_range_test1 partition(p1) on existing column detail;
update statistics for table pt_range_test1 partition(p1) clear;
update statistics for table pt_range_test1  on every column;
showstats for table pt_range_test1 on existing column detail;
update statistics for table pt_range_test1 create sample random 100 percent;
update statistics for table pt_range_test1 remove sample;
update statistics for table pt_range_test1 partition(p1) create sample random 100 percent;
update statistics for table pt_range_test1 partition(p1) remove sample;
update statistics for table pt_range_test1 clear;

-- ========================== DELETE ===================================

delete from pt_range_test1;
delete from pt_range_test1 partition (p1);
delete from pt_range_test1 partition (p1) t;
delete from pt_range_test1 partition (p1) t where pid = 10;
delete from pt_range_test1 partition (p1) t where pid = 100000;
delete from pt_range_test1 partition for (1);
delete from pt_range_test1 partition for (1) t;
delete from pt_range_test1 partition for (1) t where pid = 10;

select * from (delete from pt_range_test2 where pid = 1) x;
select * from (delete from pt_range_test2 partition (p1)) x;
insert into pt_range_test2 values (1, 'hello'),(1001, 'hello');
select * from (delete from pt_range_test2) x;
insert into pt_range_test2 values (1, 'hello'),(1001, 'hello');
select * from (delete from pt_range_test2 return "OLD".pname) x(pname);


-- negetive test, all of follow SQL shoule be error.
delete from pt_range_test1 partition;
delete from pt_range_test1 partition (p3) t;
delete from pt_range_test1 partition (p1, p2);
delete from pt_range_test1 partition for (1, 2);
delete from pt_range_test1 partition for (10000) t where pid = 10;


?section test_DDL
drop index INDEX_IDX1_PART_PT_RANGE_TEST1_P1_;
drop index idx1;
drop table PART_PT_RANGE_TEST1_P1_;
drop table pt_range_test1;
drop table pt_range_test_normal;
drop table pt_range_partition;
drop table pt_range_test4;

create table pt_range_test_split(
  id    int,
  pid   numeric(10),
  pname varchar(30)
) partition by range(id)(
  partition p1 values less than(1000),
  partition p2 values less than(2000),
  partition p3 values less than(5000)
);

insert into pt_range_test_split values(1,1,'a');
insert into pt_range_test_split values(500,500,'b');
insert into pt_range_test_split values(1000,1000,'b');
insert into pt_range_test_split values(2000,2000,'b');
insert into pt_range_test_split values(3000,3000,'b');
insert into pt_range_test_split values(4000,4000,'b');

select * from pt_range_test_split partition (p1);
select * from pt_range_test_split partition (p2);
select * from pt_range_test_split partition (p3);

-- negetive test
alter table pt_range_test_splitxx split partition p1 at (500) into (partition p11, partition p12);
alter table pt_range_test_split split partition p11 at (500) into (partition p11, partition p12);
alter table pt_range_test_split split partition p1 at (1500) into (partition p41, partition p15);
alter table pt_range_test_split split partition p4 at (4000) into (partition p4, partition p4);
alter table pt_range_test_split split partition for(109) at (4000) into (partition p41, partition p51);

alter table pt_range_test_split split partition p3 at (3000) into (partition p31, partition p4);
select * from pt_range_test_split partition (p31);
select * from pt_range_test_split partition (p4);
showddl pt_range_test_split;
alter table pt_range_test_split split partition for(500) at (500) into (partition p0, partition p11);
select * from pt_range_test_split partition (p0);
select * from pt_range_test_split partition (p11);
showddl pt_range_test_split;

-- with view
create table part_tab (c1 int,c2 int,c3 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30)
);
upsert using load into part_tab select element,element,element from udf(series(1,20));
create view v_part_tab as select * from part_tab;
create view v_part_tab2 as select c2,c3 from part_tab;
create view v_part_tab3 as select c1,c2,c3 from part_tab;
drop table part_tab ;
drop table part_tab cascade;

create table test_sch (c1 int ,c2 int,c3 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30)
);
set schema seabase;
select * from trafodion.testpartition.test_sch;
insert into trafodion.testpartition.test_sch values(1,1,1);
delete from trafodion.testpartition.test_sch;
alter table trafodion.testpartition.test_sch drop partition p1;
set schema testpartition;

-- mantis 20848, convert numeric to varchar
create table pt_range_test6 (
   c_char char(50),
   c_char_upshift char(50) upshift,
   c_char_not_casespecific char(50) not casespecific,
   c_char_varying char varying(50),
   c_char_varying_upshift char varying(50) upshift,
   c_char_varying_not_casespecific char varying(50) not casespecific,
   c_varchar varchar(50), ---not null unique,
   c_varchar_upshift varchar(50) upshift,
   c_varchar_not_casespecific varchar(50) not casespecific,
   c_nchar nchar(50),
   c_nchar_upshift nchar(50) upshift,
   c_nchar_not_casespecific nchar(50) not casespecific,
   c_nchar_varying nchar varying(50),
   c_nchar_varying_upshift nchar varying(50) upshift,
   c_nchar_varying_not_casespecific nchar varying(50) not casespecific,
   c_numeric numeric(9,2),
   c_numeric_unsigned numeric(9,2) unsigned,
   c_decimal decimal(9,2),
   c_decimal_unsigned decimal(9,2) unsigned,
   c_integer integer,
   c_integer_unsigned integer unsigned,
   c_largeint largeint,
   c_smallint smallint,
   c_smallint_unsigned smallint unsigned,
   c_float float(10),
   c_real real,
   c_double_precision double precision,
   c_date date,
   c_time time, -- default is (0)
   c_time5 time(5),
   c_timestamp timestamp, -- default is (6)
   c_timestamp5 timestamp(5),
   c_interval interval year to month,
   "c_name,with_comma" int, -- reserved word
   "YEAR" int, -- reserved word
   c_sequence LARGEINT GENERATED ALWAYS AS IDENTITY
                                   (START WITH 1
                                   INCREMENT BY 3
                                   MAXVALUE 99999999999
                                   MINVALUE 1
                                   NO CYCLE
                                   CACHE 30
                                   ),
   c_clob clob,
   c_blob blob,
   primary key (c_varchar,c_date)
   )
   partition by range(c_varchar)
   (
    partition p1 values less than (10),
    partition p2 values less than (20),
    partition p3 values less than (30),
    partition pmax values less than (maxvalue)
   );
showddl pt_range_test6;
select * from pt_range_test6;
drop table if exists pt_range_test6 cascade;

drop table if exists part_tab cascade;
create table part_tab (c1 int primary key,c2 int,c3 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30),
partition pmax values less than (maxvalue)
);
upsert using load into part_tab select element,element,element from udf(series(1,2000));

explain options 'f' delete from part_tab where c1=21;
explain options 'f' delete from part_tab where c1=31;
explain options 'f' delete from part_tab where c1=2;
drop table if exists part_tab cascade;

drop table if exists part_tab2 cascade;
create table part_tab2 (c1 int,c2 int,c3 int,primary key(c1,c2))
partition by range(c1,c2)
(
partition p1 values less than (10,15),
partition p2 values less than (20,25),
partition p3 values less than (30,35),
partition pmax values less than (maxvalue,45)
);
upsert using load into part_tab2 select element,element,element from udf(series(1,2000));

explain options 'f' delete from part_tab2 where c1=21 and c2=27;
explain options 'f' delete from part_tab2 where c1=31 and c2=15;
explain options 'f' delete from part_tab2 where c1=2 and c2=10;
explain options 'f' delete from part_tab2 where c1=10 and c2=25;
explain options 'f' delete from part_tab2 where c1=10 and c2=30;
drop table if exists part_tab2 cascade;

drop table if exists part_tab3 cascade;
create table part_tab3 (c1 int,c2 int,c3 int,primary key(c1,c2))
partition by range(c1,c2)
(
partition p1 values less than (10,15),
partition p2 values less than (20,25),
partition p3 values less than (30,35),
partition pmax values less than (40, maxvalue)
);
upsert using load into part_tab3 select element,element,element from udf(series(1,2000));

explain options 'f' delete from part_tab3 where c1=41 and c2=27;
explain options 'f' delete from part_tab3 where c1=31 and c2=155;
explain options 'f' delete from part_tab3 where c1=40 and c2=1550;
drop table if exists part_tab3 cascade;

drop table if exists part_tab4 cascade;
drop table if exists tmp1 cascade;
create table part_tab4 (c1 int ,c2 int,c3 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30)
);
upsert using load into part_tab4 select element,element,element from udf(series(1,29));
create table tmp1(id int ,value int);
upsert into tmp1 select element,element from udf(series(1,200));
select count(*) from part_tab4 where c1 in (select id from tmp1);
select count(*) from part_tab4 where c1 not in (select id from tmp1);
update part_tab4 set c2=1 where c1 not in(-1,1,4,5,6,7,8,4000);
delete from part_tab4 where c1 not in(-1,1,4,5,6,7,8,4000);
drop table if exists part_tab4 cascade;
drop table if exists tmp1 cascade;

create table pt_range_test7(c1 int, c2 int, c3 int )
partition by range(c1,c2)
(
  partition p1 values less than (10,maxvalue),
  partition p2 values less than (20,maxvalue),
  partition p3 values less than (30, 50),
  partition p4 values less than (40,maxvalue)
);
-- insert into p1
insert into pt_range_test7 values(5, 100, 10);
insert into pt_range_test7 values(10, 200, 10);
insert into pt_range_test7 partition for(5, 10) values(6, 40, 10);
insert into pt_range_test7 partition for(10, 150) values(9, 60, 10);

-- insert into p2
insert into pt_range_test7 values(15, 300, 10);
insert into pt_range_test7 values(20, 400, 10);
insert into pt_range_test7 partition for(15, 10) values(16, 55, 10);
insert into pt_range_test7 partition for(20, 350) values(19, 70, 10);

-- insert into p3
insert into pt_range_test7 values(25, 30, 10);
insert into pt_range_test7 values(30, 40, 10);
insert into pt_range_test7 partition for(25, 40) values(21, 80, 10);
insert into pt_range_test7 partition for(30, 45) values(29, 88, 10);

-- insert into p4
insert into pt_range_test7 values(35, 50, 10);
insert into pt_range_test7 values(40, 500, 10);
insert into pt_range_test7 partition for(30, 50) values(30, 55, 10);
insert into pt_range_test7 partition for(35, 48) values(40, 65, 10);
insert into pt_range_test7 partition for(40, 550) values(40, 600, 10);

-- insert 0 row
insert into pt_range_test7 partition for(40, 550) values(41, 650, 10);

-- select p1
select * from pt_range_test7 partition(p1);
select * from pt_range_test7 partition for(5, 200);
select * from pt_range_test7 partition for(10, 300);

-- select p2
select * from pt_range_test7 partition(p2);
select * from pt_range_test7 partition for(15, 400);
select * from pt_range_test7 partition for(20, 500);

-- select p3
select * from pt_range_test7 partition(p3);
select * from pt_range_test7 partition for(25, 60);
select * from pt_range_test7 partition for(30, 49);

-- select p4
select * from pt_range_test7 partition(p4);
select * from pt_range_test7 partition for(30, 50);
select * from pt_range_test7 partition for(35, 100);
select * from pt_range_test7 partition for(40, 700);

drop table pt_range_test7;

create table "p1"(
  "pid"   numeric(10),
  "pname" varchar(30),
  pname   varchar(30),
  primary key ("pid")
) partition by range("pid")(
  partition p1 values less than(1000),
  partition "p2" values less than(2000),
  partition p2 values less than(MAXVALUE)
);
showddl "p1";
insert into "p1" values(1001, '1001', '1001');
insert into "p1" values(1999, '1999', '1999');
insert into "p1" values(2001, '2001', '2001');
select * from "p1" partition ("p2");
alter table "p1" split partition "p2" at (1500) into (partition "p21", partition "p22");
select * from "p1" partition ("p21");
select * from "p1" partition ("p22");
showddl "p1";
select * from "p1" partition (p2);
drop table "p1";

create table part_tab_test_in_not_in (c1 int primary key,c2 int,c3 int)
partition by range(c1)
(
partition p1 values less than (10),
partition p2 values less than (20),
partition p3 values less than (30),
partition pmax values less than (maxvalue)
);
upsert using load into part_tab_test_in_not_in select element,element,element from udf(series(1,200));
delete from part_tab_test_in_not_in where c1 in(1,2,3) and c2 not in(1,2,3);
select * from part_tab_test_in_not_in where c1 in(1,2,3) and c1 not in(5,6,7);
select * from part_tab_test_in_not_in where c1 in(1,2,3) and c2 not in(5,6,7);
delete from part_tab_test_in_not_in where c1 in(1,2,3) and c2 not in(5,6,7);
select * from part_tab_test_in_not_in where c1 <10 and not exists(select * from part_tab_test_in_not_in);
delete from part_tab_test_in_not_in where c1 <10 and not exists(select * from part_tab_test_in_not_in);
select * from part_tab_test_in_not_in where c1 not in(40,55,70,34,46) and c1 in(5);
delete from part_tab_test_in_not_in where c1 not in(40,55,70,34,46) and c1 in(5);
drop table part_tab_test_in_not_in;

?section clean_up
cleanup table pt_range_test1 partition p1;
cleanup table pt_range_test1;
cleanup schema testpartition;
cleanup metadata;

drop schema if exists testpartition cascade;
